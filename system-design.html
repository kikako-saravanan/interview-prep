<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>90-Day System Design Mastery Plan</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #667eea;
            --primary-dark: #5a6fd8;
            --secondary: #764ba2;
            --accent: #f093fb;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --dark: #1f2937;
            --light: #f8fafc;
            --gray: #6b7280;
            --border: #e5e7eb;
            --gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --gradient-light: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            line-height: 1.6;
            color: var(--dark);
            background: var(--light);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }

        /* Header */
        header {
            background: var(--gradient);
            color: white;
            padding: 2rem 0;
            position: relative;
            overflow: hidden;
        }

        header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="50" cy="50" r="2" fill="white" opacity="0.1"/></svg>') repeat;
            animation: float 20s infinite linear;
        }

        @keyframes float {
            0% {
                transform: translateY(0px);
            }

            100% {
                transform: translateY(-100px);
            }
        }

        .hero {
            position: relative;
            z-index: 1;
            text-align: center;
        }

        .hero h1 {
            font-size: 3.5rem;
            font-weight: 800;
            margin-bottom: 1rem;
            background: linear-gradient(45deg, #fff, #f0f0f0);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .hero p {
            font-size: 1.25rem;
            margin-bottom: 2rem;
            opacity: 0.9;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 2rem;
            margin-top: 3rem;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 2rem;
            text-align: center;
            transition: transform 0.3s ease;
        }

        .stat-card:hover {
            transform: translateY(-5px);
        }

        .stat-number {
            font-size: 2.5rem;
            font-weight: 800;
            display: block;
            margin-bottom: 0.5rem;
        }

        /* Navigation */
        .nav-tabs {
            background: white;
            border-bottom: 1px solid var(--border);
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .nav-container {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 0.5rem;
            padding: 1rem;
        }

        .nav-tab {
            padding: 0.75rem 1.5rem;
            background: transparent;
            border: 2px solid transparent;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            color: var(--gray);
        }

        .nav-tab.active {
            background: var(--gradient);
            color: white;
            border-color: var(--primary);
        }

        .nav-tab:hover:not(.active) {
            background: var(--gradient-light);
            border-color: var(--primary);
        }

        /* Main Content */
        main {
            padding: 3rem 0;
        }

        .section {
            display: none;
            animation: fadeIn 0.5s ease-in;
        }

        .section.active {
            display: block;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Week Cards */
        .weeks-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 2rem;
            margin-bottom: 3rem;
        }

        .week-card {
            background: white;
            border-radius: 16px;
            padding: 2rem;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            border: 1px solid var(--border);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .week-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: var(--gradient);
        }

        .week-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.15);
        }

        .week-header {
            display: flex;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .week-number {
            width: 60px;
            height: 60px;
            background: var(--gradient);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 800;
            font-size: 1.25rem;
            margin-right: 1rem;
        }

        .week-title {
            flex: 1;
        }

        .week-title h3 {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 0.25rem;
            color: var(--dark);
        }

        .week-subtitle {
            color: var(--gray);
            font-size: 0.95rem;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #f1f5f9;
            border-radius: 4px;
            margin: 1rem 0;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: var(--gradient);
            border-radius: 4px;
            width: 0%;
            transition: width 0.6s ease;
        }

        .days-list {
            list-style: none;
        }

        .day-item {
            padding: 0.75rem 0;
            border-bottom: 1px solid #f1f5f9;
            display: flex;
            align-items: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .day-item:hover {
            background: rgba(102, 126, 234, 0.05);
            margin: 0 -1rem;
            padding-left: 1rem;
            padding-right: 1rem;
            border-radius: 8px;
        }

        .day-checkbox {
            width: 20px;
            height: 20px;
            border: 2px solid var(--border);
            border-radius: 4px;
            margin-right: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .day-checkbox.completed {
            background: var(--success);
            border-color: var(--success);
            color: white;
        }

        .day-content {
            flex: 1;
        }

        .day-title {
            font-weight: 600;
            margin-bottom: 0.25rem;
        }

        .day-desc {
            font-size: 0.875rem;
            color: var(--gray);
        }

        /* Day Detail Modal */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 16px;
            max-width: 800px;
            max-height: 90vh;
            overflow-y: auto;
            margin: 2rem;
            position: relative;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.2);
        }

        .modal-header {
            background: var(--gradient);
            color: white;
            padding: 2rem;
            border-radius: 16px 16px 0 0;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .modal-close {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-body {
            padding: 2rem;
        }

        .activity-section {
            margin-bottom: 2rem;
        }

        .activity-section h4 {
            color: var(--primary);
            font-weight: 700;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
        }

        .activity-section h4::before {
            content: '';
            width: 4px;
            height: 20px;
            background: var(--primary);
            margin-right: 0.75rem;
            border-radius: 2px;
        }

        .study-links {
            display: grid;
            gap: 0.75rem;
            margin: 1rem 0;
        }

        .study-link {
            display: flex;
            align-items: center;
            padding: 0.75rem;
            background: #f8fafc;
            border-radius: 8px;
            text-decoration: none;
            color: var(--primary);
            transition: all 0.3s ease;
            border: 1px solid transparent;
        }

        .study-link:hover {
            background: var(--gradient-light);
            border-color: var(--primary);
        }

        .problems-list {
            background: #fef3c7;
            border-left: 4px solid var(--warning);
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
        }

        .problems-list h5 {
            color: #92400e;
            margin-bottom: 0.5rem;
        }

        /* Study Guide Styles */
        .study-guide-week {
            background: white;
            border-radius: 16px;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        }

        .week-header-guide {
            color: var(--primary);
            font-size: 1.75rem;
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 3px solid var(--primary);
        }

        .day-guide-card {
            background: #f8fafc;
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            border-left: 4px solid var(--primary);
        }

        .day-guide-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .day-number-badge {
            background: var(--gradient);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            font-weight: 700;
            font-size: 0.875rem;
        }

        .day-guide-header h4 {
            color: var(--dark);
            font-size: 1.25rem;
            margin: 0;
        }

        .concepts-section h5 {
            color: var(--primary);
            font-size: 1.1rem;
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
            font-weight: 700;
        }

        .concepts-list {
            list-style: none;
            padding-left: 0;
        }

        .concepts-list>li {
            margin-bottom: 1rem;
            padding-left: 1.5rem;
            position: relative;
        }

        .concepts-list>li::before {
            content: '▶';
            position: absolute;
            left: 0;
            color: var(--primary);
            font-size: 0.75rem;
        }

        .concepts-list ul {
            margin-top: 0.5rem;
            margin-left: 1rem;
            list-style: disc;
            color: var(--gray);
        }

        .concepts-list ul li {
            margin-bottom: 0.25rem;
            padding-left: 0.5rem;
        }

        .practice-list {
            list-style: none;
            padding-left: 0;
            background: white;
            padding: 1rem;
            border-radius: 8px;
        }

        .practice-list li {
            margin-bottom: 0.75rem;
            padding-left: 1.5rem;
            position: relative;
        }

        .practice-list li::before {
            content: '✓';
            position: absolute;
            left: 0;
            color: var(--success);
            font-weight: bold;
        }

        .resources-list {
            list-style: none;
            padding-left: 0;
            background: #ede9fe;
            padding: 1rem;
            border-radius: 8px;
        }

        .resources-list li {
            margin-bottom: 0.5rem;
            padding-left: 1.5rem;
            position: relative;
            color: var(--dark);
        }

        .resources-list li::before {
            content: '📌';
            position: absolute;
            left: 0;
        }

        code {
            background: #e2e8f0;
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 0.875rem;
        }


        /* Responsive Design */
        @media (max-width: 768px) {
            .hero h1 {
                font-size: 2.5rem;
            }

            .stats {
                grid-template-columns: repeat(2, 1fr);
            }

            .weeks-grid {
                grid-template-columns: 1fr;
            }

            .nav-container {
                flex-direction: column;
                align-items: center;
            }

            .modal-content {
                margin: 1rem;
                max-height: 95vh;
            }
        }

        /* Additional Animations */
        .bounce-in {
            animation: bounceIn 0.6s ease-out;
        }

        @keyframes bounceIn {
            0% {
                transform: scale(0.3);
                opacity: 0;
            }

            50% {
                transform: scale(1.05);
            }

            70% {
                transform: scale(0.9);
            }

            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        .slide-up {
            animation: slideUp 0.6s ease-out;
        }

        @keyframes slideUp {
            from {
                transform: translateY(30px);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
    </style>
</head>

<body>
    <!-- Header Section -->
    <header>
        <div class="container">
            <div class="hero">
                <h1>90-Day System Design Mastery</h1>
                <p>Transform from beginner to interview-ready system design expert</p>

                <div class="stats">
                    <div class="stat-card">
                        <span class="stat-number">90</span>
                        <span>Days to Mastery</span>
                    </div>
                    <div class="stat-card">
                        <span class="stat-number">12</span>
                        <span>Comprehensive Weeks</span>
                    </div>
                    <div class="stat-card">
                        <span class="stat-number">40%</span>
                        <span>Hands-on Practice</span>
                    </div>
                    <div class="stat-card">
                        <span class="stat-number">100+</span>
                        <span>Real Problems</span>
                    </div>
                </div>
            </div>
        </div>
    </header>

    <!-- Navigation -->
    <nav class="nav-tabs">
        <div class="container">
            <div class="nav-container">
                <button class="nav-tab active" onclick="showSection('overview')">📋 Overview</button>
                <button class="nav-tab" onclick="showSection('weeks1-4')">🏗️ Foundation (Weeks 1-4)</button>
                <button class="nav-tab" onclick="showSection('weeks5-8')">⚡ Practice (Weeks 5-8)</button>
                <button class="nav-tab" onclick="showSection('weeks9-12')">🎯 Mastery (Weeks 9-12)</button>
                <button class="nav-tab" onclick="showSection('progress')">📈 Progress</button>
                <button class="nav-tab" onclick="showSection('study-guide')">📚 Study Guide</button>
            </div>
        </div>
    </nav>

    <!-- Main Content -->
    <main>
        <div class="container">
            <!-- Overview Section -->
            <div id="overview" class="section active">
                <div
                    style="background: white; border-radius: 16px; padding: 3rem; margin-bottom: 2rem; box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);">
                    <h2 style="color: var(--primary); font-size: 2.5rem; margin-bottom: 2rem; text-align: center;">Your
                        Journey to System Design Excellence</h2>

                    <div
                        style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 2rem; margin-bottom: 3rem;">
                        <div style="text-align: center; padding: 2rem;">
                            <div
                                style="width: 80px; height: 80px; background: var(--gradient); border-radius: 50%; display: flex; align-items: center; justify-content: center; margin: 0 auto 1rem; font-size: 2rem;">
                                🎯</div>
                            <h3 style="color: var(--dark); margin-bottom: 1rem;">Target Audience</h3>
                            <p style="color: var(--gray);">Beginners with basic programming knowledge ready to master
                                system design</p>
                        </div>
                        <div style="text-align: center; padding: 2rem;">
                            <div
                                style="width: 80px; height: 80px; background: var(--gradient); border-radius: 50%; display: flex; align-items: center; justify-content: center; margin: 0 auto 1rem; font-size: 2rem;">
                                ⏰</div>
                            <h3 style="color: var(--dark); margin-bottom: 1rem;">Time Commitment</h3>
                            <p style="color: var(--gray);">1.5-2 hours weekdays, 3-4 hours weekends</p>
                        </div>
                        <div style="text-align: center; padding: 2rem;">
                            <div
                                style="width: 80px; height: 80px; background: var(--gradient); border-radius: 50%; display: flex; align-items: center; justify-content: center; margin: 0 auto 1rem; font-size: 2rem;">
                                🚀</div>
                            <h3 style="color: var(--dark); margin-bottom: 1rem;">Approach</h3>
                            <p style="color: var(--gray);">40% hands-on, 30% theory, 20% problems, 10% mock interviews
                            </p>
                        </div>
                    </div>

                    <div
                        style="background: var(--gradient-light); border-radius: 12px; padding: 2rem; border-left: 4px solid var(--primary);">
                        <h3 style="color: var(--primary); margin-bottom: 1rem;">Why This Sequence Works</h3>
                        <p style="color: var(--dark); line-height: 1.7;">Each topic builds upon previous knowledge,
                            starting with fundamentals and progressively adding complexity. Modern requirements (AI/ML
                            systems, cloud-native patterns) are integrated throughout rather than treated as separate
                            topics, ensuring you're ready for 2025's industry demands.</p>
                    </div>
                </div>
            </div>

            <!-- Foundation Weeks 1-4 -->
            <div id="weeks1-4" class="section">
                <h2 style="color: var(--primary); font-size: 2.5rem; margin-bottom: 2rem; text-align: center;">
                    Foundation & Core Components</h2>
                <p style="text-align: center; color: var(--gray); margin-bottom: 3rem; font-size: 1.125rem;">Build your
                    system design foundation with essential concepts and modern architecture patterns</p>

                <div class="weeks-grid" id="foundationWeeks">
                    <!-- Weeks 1-4 will be populated by JavaScript -->
                </div>
            </div>

            <!-- Practice Weeks 5-8 -->
            <div id="weeks5-8" class="section">
                <h2 style="color: var(--primary); font-size: 2.5rem; margin-bottom: 2rem; text-align: center;">System
                    Design Problems Practice</h2>
                <p style="text-align: center; color: var(--gray); margin-bottom: 3rem; font-size: 1.125rem;">Master
                    classic and advanced system design problems through intensive practice</p>

                <div class="weeks-grid" id="practiceWeeks">
                    <!-- Weeks 5-8 will be populated by JavaScript -->
                </div>
            </div>

            <!-- Mastery Weeks 9-12 -->
            <div id="weeks9-12" class="section">
                <h2 style="color: var(--primary); font-size: 2.5rem; margin-bottom: 2rem; text-align: center;">Interview
                    Mastery & Advanced Topics</h2>
                <p style="text-align: center; color: var(--gray); margin-bottom: 3rem; font-size: 1.125rem;">Perfect
                    your interview technique and explore cutting-edge system design patterns</p>

                <div class="weeks-grid" id="masteryWeeks">
                    <!-- Weeks 9-12 will be populated by JavaScript -->
                </div>
            </div>

            <!-- Progress Section -->
            <div id="progress" class="section">
                <h2 style="color: var(--primary); font-size: 2.5rem; margin-bottom: 2rem; text-align: center;">Track
                    Your Progress</h2>

                <div
                    style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 2rem; margin-bottom: 3rem;">
                    <div
                        style="background: white; border-radius: 16px; padding: 2rem; box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1); text-align: center;">
                        <h3 style="color: var(--success); margin-bottom: 1rem;">Days Completed</h3>
                        <div style="font-size: 3rem; font-weight: 800; color: var(--success);" id="completedDays">0
                        </div>
                        <div style="color: var(--gray);">out of 90 days</div>
                    </div>
                    <div
                        style="background: white; border-radius: 16px; padding: 2rem; box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1); text-align: center;">
                        <h3 style="color: var(--primary); margin-bottom: 1rem;">Current Week</h3>
                        <div style="font-size: 3rem; font-weight: 800; color: var(--primary);" id="currentWeek">1</div>
                        <div style="color: var(--gray);">of 12 weeks</div>
                    </div>
                    <div
                        style="background: white; border-radius: 16px; padding: 2rem; box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1); text-align: center;">
                        <h3 style="color: var(--warning); margin-bottom: 1rem;">Completion Rate</h3>
                        <div style="font-size: 3rem; font-weight: 800; color: var(--warning);" id="completionRate">0%
                        </div>
                        <div style="color: var(--gray);">overall progress</div>
                    </div>
                </div>

                <div
                    style="background: white; border-radius: 16px; padding: 2rem; box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);">
                    <h3 style="color: var(--dark); margin-bottom: 2rem;">Weekly Progress Overview</h3>
                    <div id="weeklyProgress">
                        <!-- Weekly progress bars will be generated by JavaScript -->
                    </div>
                </div>
            </div>

            <!-- Add this to your navigation tabs -->
            <button class="nav-tab" onclick="showSection('study-guide')">📚 Study Guide</button>

            <!-- Study guide -->
            <div id="study-guide" class="section">
                <h2 style="color: var(--primary); font-size: 2.5rem; margin-bottom: 2rem; text-align: center;">
                    Complete Study Guide - Topics & Concepts
                </h2>
                <p style="text-align: center; color: var(--gray); margin-bottom: 3rem; font-size: 1.125rem;">
                    Detailed breakdown of every concept you need to learn and practice for each day
                </p>

                <!-- Week 1: Foundation & Prerequisites -->
                <div class="study-guide-week">
                    <h3 class="week-header-guide">Week 1: Foundation & Prerequisites (Days 1-7)</h3>

                    <!-- Day 1 -->
                    <div class="day-guide-card">
                        <div class="day-guide-header">
                            <span class="day-number-badge">Day 1</span>
                            <h4>Programming Fundamentals Review</h4>
                        </div>

                        <div class="concepts-section">
                            <h5>🎯 Core Concepts to Learn:</h5>
                            <ul class="concepts-list">
                                <li><strong>Object-Oriented Programming:</strong>
                                    <ul>
                                        <li>4 Pillars: Encapsulation, Abstraction, Inheritance, Polymorphism</li>
                                        <li>Classes vs Objects vs Interfaces</li>
                                        <li>Composition vs Inheritance (favor composition)</li>
                                        <li>SOLID principles overview</li>
                                    </ul>
                                </li>
                                <li><strong>Data Structures:</strong>
                                    <ul>
                                        <li>Arrays: Static vs Dynamic, time complexity O(1) access</li>
                                        <li>Linked Lists: Singly, Doubly, use cases</li>
                                        <li>Hash Tables: Hash functions, collision handling (chaining, open addressing)
                                        </li>
                                        <li>Trees: Binary trees, BST properties, traversal methods</li>
                                        <li>Stacks & Queues: LIFO vs FIFO, use cases</li>
                                    </ul>
                                </li>
                                <li><strong>Time & Space Complexity:</strong>
                                    <ul>
                                        <li>Big O notation: O(1), O(log n), O(n), O(n log n), O(n²)</li>
                                        <li>Best, average, worst case analysis</li>
                                        <li>Space-time tradeoffs</li>
                                        <li>Amortized time complexity</li>
                                    </ul>
                                </li>
                            </ul>

                            <h5>💻 Practice Tasks:</h5>
                            <ul class="practice-list">
                                <li>Implement hash table from scratch with chaining</li>
                                <li>Handle collisions using separate chaining</li>
                                <li>Implement dynamic resizing (rehashing)</li>
                                <li>Code BST with insert, delete, search operations</li>
                                <li>Solve LeetCode #1 (Two Sum) - understand hash table usage</li>
                                <li>Solve LeetCode #217 (Contains Duplicate)</li>
                            </ul>

                            <h5>📖 Key Resources:</h5>
                            <ul class="resources-list">
                                <li>Big O Cheat Sheet: bigocheatsheet.com</li>
                                <li>Visualize data structures: visualgo.net</li>
                                <li>OOP concepts review</li>
                            </ul>
                        </div>
                    </div>

                    <!-- Day 2 -->
                    <div class="day-guide-card">
                        <div class="day-guide-header">
                            <span class="day-number-badge">Day 2</span>
                            <h4>Network Fundamentals</h4>
                        </div>

                        <div class="concepts-section">
                            <h5>🎯 Core Concepts to Learn:</h5>
                            <ul class="concepts-list">
                                <li><strong>HTTP/HTTPS Protocol:</strong>
                                    <ul>
                                        <li>Request methods: GET, POST, PUT, DELETE, PATCH</li>
                                        <li>Status codes: 2xx (success), 3xx (redirect), 4xx (client error), 5xx (server
                                            error)</li>
                                        <li>Headers: Content-Type, Authorization, Cache-Control, Cookie</li>
                                        <li>HTTPS: SSL/TLS handshake, certificates, encryption</li>
                                        <li>HTTP/1.1 vs HTTP/2 vs HTTP/3</li>
                                    </ul>
                                </li>
                                <li><strong>TCP vs UDP:</strong>
                                    <ul>
                                        <li>TCP: Connection-oriented, reliable, ordered delivery, flow control</li>
                                        <li>UDP: Connectionless, fast, no guarantee of delivery</li>
                                        <li>3-way handshake (SYN, SYN-ACK, ACK)</li>
                                        <li>When to use each protocol</li>
                                    </ul>
                                </li>
                                <li><strong>Client-Server Architecture:</strong>
                                    <ul>
                                        <li>Request-response model</li>
                                        <li>Stateless vs stateful protocols</li>
                                        <li>Connection pooling</li>
                                    </ul>
                                </li>
                                <li><strong>DNS (Domain Name System):</strong>
                                    <ul>
                                        <li>DNS hierarchy: Root → TLD → Authoritative</li>
                                        <li>DNS resolution process (recursive vs iterative)</li>
                                        <li>DNS caching (browser, OS, ISP)</li>
                                        <li>DNS records: A, AAAA, CNAME, MX, TXT</li>
                                    </ul>
                                </li>
                            </ul>

                            <h5>💻 Practice Tasks:</h5>
                            <ul class="practice-list">
                                <li>Use curl to analyze HTTP headers: <code>curl -I https://google.com</code></li>
                                <li>Build simple HTTP server (Node.js/Python)</li>
                                <li>Create client that parses response headers</li>
                                <li>Use nslookup/dig to trace DNS queries</li>
                                <li>Capture network traffic with Wireshark</li>
                                <li>Implement basic TCP client-server communication</li>
                            </ul>

                            <h5>📖 Key Terms to Master:</h5>
                            <ul class="resources-list">
                                <li>Latency, Bandwidth, Throughput</li>
                                <li>Keep-Alive connections</li>
                                <li>Network protocols layering (OSI model)</li>
                            </ul>
                        </div>
                    </div>

                    <!-- Day 3 -->
                    <div class="day-guide-card">
                        <div class="day-guide-header">
                            <span class="day-number-badge">Day 3</span>
                            <h4>Database Fundamentals</h4>
                        </div>

                        <div class="concepts-section">
                            <h5>🎯 Core Concepts to Learn:</h5>
                            <ul class="concepts-list">
                                <li><strong>Relational Databases:</strong>
                                    <ul>
                                        <li>Tables, rows, columns, schemas</li>
                                        <li>Primary key (unique identifier)</li>
                                        <li>Foreign key (referential integrity)</li>
                                        <li>Normalization: 1NF, 2NF, 3NF (eliminate redundancy)</li>
                                        <li>Denormalization for performance</li>
                                    </ul>
                                </li>
                                <li><strong>ACID Properties:</strong>
                                    <ul>
                                        <li><strong>Atomicity:</strong> All or nothing (transaction completes fully or
                                            not at all)</li>
                                        <li><strong>Consistency:</strong> Valid state before and after transaction</li>
                                        <li><strong>Isolation:</strong> Concurrent transactions don't interfere</li>
                                        <li><strong>Durability:</strong> Committed data persists after crashes</li>
                                    </ul>
                                </li>
                                <li><strong>SQL Operations:</strong>
                                    <ul>
                                        <li>CRUD: CREATE, READ, UPDATE, DELETE</li>
                                        <li>JOINs: INNER, LEFT, RIGHT, FULL OUTER</li>
                                        <li>Aggregate functions: COUNT, SUM, AVG, MAX, MIN</li>
                                        <li>GROUP BY, HAVING, ORDER BY</li>
                                        <li>Subqueries and CTEs (Common Table Expressions)</li>
                                    </ul>
                                </li>
                                <li><strong>Indexes:</strong>
                                    <ul>
                                        <li>B-tree index (most common, good for range queries)</li>
                                        <li>Hash index (exact match lookups)</li>
                                        <li>Composite indexes (multiple columns)</li>
                                        <li>When indexes help vs hurt (write overhead)</li>
                                        <li>EXPLAIN QUERY PLAN analysis</li>
                                    </ul>
                                </li>
                            </ul>

                            <h5>💻 Practice Tasks:</h5>
                            <ul class="practice-list">
                                <li>Design e-commerce schema: users, products, orders, order_items</li>
                                <li>Write complex JOINs (e.g., user orders with product details)</li>
                                <li>Create indexes on frequently queried columns</li>
                                <li>Use EXPLAIN to analyze query performance</li>
                                <li>Design Twitter schema: users, tweets, follows, likes</li>
                                <li>Implement foreign key constraints</li>
                            </ul>

                            <h5>📖 Key Questions to Answer:</h5>
                            <ul class="resources-list">
                                <li>When should you denormalize?</li>
                                <li>What's the cost of too many indexes?</li>
                                <li>How do transactions ensure ACID?</li>
                            </ul>
                        </div>
                    </div>

                    <!-- Day 4 -->
                    <div class="day-guide-card">
                        <div class="day-guide-header">
                            <span class="day-number-badge">Day 4</span>
                            <h4>System Building Blocks Introduction</h4>
                        </div>

                        <div class="concepts-section">
                            <h5>🎯 Core Concepts to Learn:</h5>
                            <ul class="concepts-list">
                                <li><strong>Architecture Patterns:</strong>
                                    <ul>
                                        <li><strong>Monolithic:</strong> Single codebase, easier to develop, harder to
                                            scale</li>
                                        <li><strong>Distributed:</strong> Multiple services, complex but scalable</li>
                                        <li>When to choose each approach</li>
                                    </ul>
                                </li>
                                <li><strong>Load Balancers:</strong>
                                    <ul>
                                        <li>Purpose: Distribute traffic across multiple servers</li>
                                        <li>Benefits: No single point of failure, better resource utilization</li>
                                        <li>Basic algorithms: Round-robin, least connections</li>
                                    </ul>
                                </li>
                                <li><strong>Caching Basics:</strong>
                                    <ul>
                                        <li>Store frequently accessed data in fast storage</li>
                                        <li>Reduces database load and latency</li>
                                        <li>Cache hit vs cache miss</li>
                                        <li>Common locations: Browser, CDN, Application, Database</li>
                                    </ul>
                                </li>
                                <li><strong>Message Queues:</strong>
                                    <ul>
                                        <li>Decouple components (producer/consumer pattern)</li>
                                        <li>Handle asynchronous processing</li>
                                        <li>Buffer requests during traffic spikes</li>
                                        <li>Examples: RabbitMQ, Kafka, SQS</li>
                                    </ul>
                                </li>
                            </ul>

                            <h5>💻 Practice Tasks:</h5>
                            <ul class="practice-list">
                                <li>Draw architecture diagram for simple web app (client → LB → servers → DB)</li>
                                <li>Identify bottlenecks: single database, no caching, no load balancing</li>
                                <li>Compare: When is monolith better than microservices?</li>
                                <li>Design improvement: Add cache layer, read replicas</li>
                            </ul>

                            <h5>📖 Key Concepts:</h5>
                            <ul class="resources-list">
                                <li>Single Point of Failure (SPOF)</li>
                                <li>Vertical vs Horizontal scaling (preview)</li>
                                <li>Synchronous vs Asynchronous processing</li>
                            </ul>
                        </div>
                    </div>

                    <!-- Day 5 -->
                    <div class="day-guide-card">
                        <div class="day-guide-header">
                            <span class="day-number-badge">Day 5</span>
                            <h4>Scalability Fundamentals</h4>
                        </div>

                        <div class="concepts-section">
                            <h5>🎯 Core Concepts to Learn:</h5>
                            <ul class="concepts-list">
                                <li><strong>Horizontal vs Vertical Scaling:</strong>
                                    <ul>
                                        <li><strong>Vertical (Scale Up):</strong> Add more CPU/RAM to single machine
                                        </li>
                                        <li>Pros: Simple, no code changes</li>
                                        <li>Cons: Hardware limits, expensive, single point of failure</li>
                                        <li><strong>Horizontal (Scale Out):</strong> Add more machines</li>
                                        <li>Pros: No hardware limits, fault tolerance</li>
                                        <li>Cons: Complex, need load balancer, data consistency challenges</li>
                                    </ul>
                                </li>
                                <li><strong>Stateless vs Stateful Services:</strong>
                                    <ul>
                                        <li><strong>Stateless:</strong> No session data stored on server, easier to
                                            scale</li>
                                        <li><strong>Stateful:</strong> Session stored on server, harder to scale (need
                                            sticky sessions or shared storage)</li>
                                        <li>Making services stateless (use external cache for sessions)</li>
                                    </ul>
                                </li>
                                <li><strong>Load Distribution Strategies:</strong>
                                    <ul>
                                        <li>Geographic distribution (multiple data centers)</li>
                                        <li>Service-based distribution (different services on different servers)</li>
                                        <li>Database read replicas</li>
                                    </ul>
                                </li>
                                <li><strong>Performance Metrics:</strong>
                                    <ul>
                                        <li>QPS (Queries Per Second) / RPS (Requests Per Second)</li>
                                        <li>Latency (response time): p50, p95, p99</li>
                                        <li>Throughput (requests handled per unit time)</li>
                                        <li>Uptime / Availability (e.g., 99.9% = 43 min downtime/month)</li>
                                    </ul>
                                </li>
                            </ul>

                            <h5>💻 Practice Tasks:</h5>
                            <ul class="practice-list">
                                <li>Design scaling strategy: 1K users → 1M users → 100M users</li>
                                <li>Calculate capacity: If each user makes 10 requests/day, what's peak QPS?</li>
                                <li>Identify bottlenecks: Database writes, network bandwidth, CPU</li>
                                <li>Convert stateful app to stateless (move sessions to Redis)</li>
                            </ul>

                            <h5>📖 Key Formulas:</h5>
                            <ul class="resources-list">
                                <li>QPS = (Daily Active Users × Actions per User) / 86400</li>
                                <li>Peak QPS ≈ 2-3× Average QPS</li>
                                <li>Availability = Uptime / (Uptime + Downtime)</li>
                            </ul>
                        </div>
                    </div>

                    <!-- Day 6 -->
                    <div class="day-guide-card">
                        <div class="day-guide-header">
                            <span class="day-number-badge">Day 6</span>
                            <h4>Introduction to Distributed Systems</h4>
                        </div>

                        <div class="concepts-section">
                            <h5>🎯 Core Concepts to Learn:</h5>
                            <ul class="concepts-list">
                                <li><strong>Distributed System Challenges:</strong>
                                    <ul>
                                        <li>Network unreliability (messages can be lost, delayed)</li>
                                        <li>Partial failures (some nodes fail while others work)</li>
                                        <li>No global clock (time synchronization is hard)</li>
                                        <li>Concurrency issues (race conditions at scale)</li>
                                    </ul>
                                </li>
                                <li><strong>Network Partitions:</strong>
                                    <ul>
                                        <li>Network split: some nodes can't communicate with others</li>
                                        <li>Split-brain problem: two parts think they're primary</li>
                                        <li>Must design systems to handle partitions gracefully</li>
                                    </ul>
                                </li>
                                <li><strong>Consistency Basics:</strong>
                                    <ul>
                                        <li><strong>Strong Consistency:</strong> All nodes see same data at same time
                                        </li>
                                        <li><strong>Eventual Consistency:</strong> Nodes eventually converge to same
                                            state</li>
                                        <li>Trade-off: Strong consistency = slower, Eventual = faster but complex</li>
                                    </ul>
                                </li>
                                <li><strong>Fault Tolerance:</strong>
                                    <ul>
                                        <li>Replication: Keep copies of data on multiple nodes</li>
                                        <li>Redundancy: No single point of failure</li>
                                        <li>Failover: Automatic switch to backup when primary fails</li>
                                        <li>Health checks and heartbeats</li>
                                    </ul>
                                </li>
                            </ul>

                            <h5>💻 Practice Tasks:</h5>
                            <ul class="practice-list">
                                <li>Design fault-tolerant system with 3 replicas</li>
                                <li>Analyze failure scenarios: What if 1 node fails? 2 nodes?</li>
                                <li>Plan recovery: How to detect failures? How to recover?</li>
                                <li>Design health check system with heartbeat mechanism</li>
                            </ul>

                            <h5>📖 Key Terms:</h5>
                            <ul class="resources-list">
                                <li>Replication factor</li>
                                <li>Quorum (N/2 + 1)</li>
                                <li>CAP theorem (preview for Week 3)</li>
                            </ul>
                        </div>
                    </div>

                    <!-- Day 7 -->
                    <div class="day-guide-card">
                        <div class="day-guide-header">
                            <span class="day-number-badge">Day 7</span>
                            <h4>Week 1 Review & Assessment</h4>
                        </div>

                        <div class="concepts-section">
                            <h5>🎯 Review Checklist:</h5>
                            <ul class="concepts-list">
                                <li>Can you explain Big O notation with examples?</li>
                                <li>Can you explain HTTP vs HTTPS?</li>
                                <li>Can you explain ACID properties with real examples?</li>
                                <li>Can you explain horizontal vs vertical scaling?</li>
                                <li>Can you draw a basic web architecture diagram?</li>
                                <li>Can you explain when to use cache vs database?</li>
                            </ul>

                            <h5>💻 Mini Project: URL Shortener (Basic)</h5>
                            <ul class="practice-list">
                                <li>Design: API endpoints (POST /shorten, GET /{shortUrl})</li>
                                <li>Generate short URL (hash function or base62 encoding)</li>
                                <li>Store mapping: short → long URL (use in-memory or simple DB)</li>
                                <li>Implement redirect logic</li>
                                <li>Consider: How would you scale to 1M URLs?</li>
                            </ul>

                            <h5>📖 Assessment:</h5>
                            <ul class="resources-list">
                                <li>Explain Week 1 concepts to someone else (Feynman technique)</li>
                                <li>Identify gaps in understanding</li>
                                <li>Review weak areas before Week 2</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <!-- Week 2: Core System Components (Days 8-14) -->

                <div class="study-guide-week">
                    <h3 class="week-header-guide">Week 2: Core System Components (Days 8-14)</h3>

                    <!-- Day 8 -->
                    <div class="day-guide-card">
                        <div class="day-guide-header">
                            <span class="day-number-badge">Day 8</span>
                            <h4>Load Balancing Strategies</h4>
                        </div>

                        <div class="concepts-section">
                            <h5>🎯 Core Concepts to Learn:</h5>
                            <ul class="concepts-list">
                                <li><strong>What is Load Balancing?</strong>
                                    <ul>
                                        <li>Distribute incoming traffic across multiple servers</li>
                                        <li>Benefits: Better performance, high availability, scalability, fault
                                            tolerance</li>
                                        <li>Without LB: Single server overwhelmed, single point of failure</li>
                                        <li>With LB: Traffic distributed, one server failure doesn't crash system</li>
                                    </ul>
                                </li>

                                <li><strong>Load Balancing Algorithms:</strong>
                                    <ul>
                                        <li><strong>Round Robin:</strong> Distribute requests equally in circular order
                                            <ul>
                                                <li>Simple and fair distribution</li>
                                                <li>Problem: Doesn't consider server load or capacity</li>
                                                <li>Use when: Servers have equal capacity, similar request processing
                                                    time</li>
                                            </ul>
                                        </li>
                                        <li><strong>Weighted Round Robin:</strong> Assign weights based on server
                                            capacity
                                            <ul>
                                                <li>More powerful servers get more requests</li>
                                                <li>Example: Server A (weight 3) gets 3x more than Server B (weight 1)
                                                </li>
                                                <li>Use when: Servers have different capacities</li>
                                            </ul>
                                        </li>
                                        <li><strong>Least Connections:</strong> Send to server with fewest active
                                            connections
                                            <ul>
                                                <li>Better for long-lived connections</li>
                                                <li>Dynamically adjusts based on server load</li>
                                                <li>Use when: Request processing time varies significantly</li>
                                            </ul>
                                        </li>
                                        <li><strong>Least Response Time:</strong> Send to server with fastest response
                                            <ul>
                                                <li>Considers both active connections and response time</li>
                                                <li>Most optimal but requires health checks</li>
                                                <li>Use when: Need best user experience</li>
                                            </ul>
                                        </li>
                                        <li><strong>IP Hash:</strong> Hash client IP to determine server
                                            <ul>
                                                <li>Same client always goes to same server</li>
                                                <li>Good for session persistence</li>
                                                <li>Problem: Uneven distribution if few clients</li>
                                            </ul>
                                        </li>
                                        <li><strong>Consistent Hashing:</strong> Minimize redistribution when servers
                                            added/removed
                                            <ul>
                                                <li>Virtual nodes for better distribution</li>
                                                <li>Only K/N keys remapped (K=keys, N=nodes)</li>
                                                <li>Use when: Frequently adding/removing servers, caching scenarios</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>

                                <li><strong>Layer 4 vs Layer 7 Load Balancing:</strong>
                                    <ul>
                                        <li><strong>Layer 4 (Transport Layer - TCP/UDP):</strong>
                                            <ul>
                                                <li>Routes based on IP address and port</li>
                                                <li>Faster (doesn't inspect packet content)</li>
                                                <li>Can't route based on URL or headers</li>
                                                <li>Examples: AWS Network Load Balancer, HAProxy (L4 mode)</li>
                                                <li>Use when: Need maximum performance, simple routing</li>
                                            </ul>
                                        </li>
                                        <li><strong>Layer 7 (Application Layer - HTTP/HTTPS):</strong>
                                            <ul>
                                                <li>Routes based on content (URL, headers, cookies)</li>
                                                <li>Can perform SSL termination</li>
                                                <li>Can route /api to API servers, /images to image servers</li>
                                                <li>Slower (must parse content)</li>
                                                <li>Examples: AWS Application Load Balancer, Nginx, HAProxy (L7 mode)
                                                </li>
                                                <li>Use when: Need content-based routing, SSL offloading</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>

                                <li><strong>Health Checks and Failover:</strong>
                                    <ul>
                                        <li><strong>Active Health Check:</strong> LB periodically pings servers
                                            <ul>
                                                <li>TCP check: Can server accept connection?</li>
                                                <li>HTTP check: Does server return 200 OK?</li>
                                                <li>Custom check: Application-specific endpoint</li>
                                            </ul>
                                        </li>
                                        <li><strong>Passive Health Check:</strong> Monitor real traffic
                                            <ul>
                                                <li>Mark server unhealthy after N failed requests</li>
                                                <li>Faster detection of issues</li>
                                            </ul>
                                        </li>
                                        <li><strong>Failover:</strong> Automatically route traffic away from failed
                                            servers
                                            <ul>
                                                <li>Circuit breaker: Stop sending requests after repeated failures</li>
                                                <li>Retry logic: Retry failed requests to different server</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>

                                <li><strong>Session Persistence (Sticky Sessions):</strong>
                                    <ul>
                                        <li>Problem: User session stored on specific server</li>
                                        <li><strong>Solutions:</strong>
                                            <ul>
                                                <li>IP-based: Route same IP to same server (IP hash)</li>
                                                <li>Cookie-based: LB sets cookie, routes based on cookie</li>
                                                <li>Better solution: Store sessions externally (Redis, database)</li>
                                            </ul>
                                        </li>
                                        <li>Trade-off: Sticky sessions vs stateless servers</li>
                                    </ul>
                                </li>

                                <li><strong>Global Server Load Balancing (GSLB):</strong>
                                    <ul>
                                        <li>Route users to nearest data center</li>
                                        <li>DNS-based: Return different IPs based on user location</li>
                                        <li>Benefits: Lower latency, disaster recovery</li>
                                        <li>Example: User in Europe → EU data center</li>
                                    </ul>
                                </li>
                            </ul>

                            <h5>💻 Practice Tasks:</h5>
                            <ul class="practice-list">
                                <li>Compare algorithms: Which for e-commerce checkout? Which for static content?</li>
                                <li>Design load balancer for video streaming service (consider long connections)</li>
                                <li>Design session handling: Sticky sessions vs external session store</li>
                                <li>Calculate: 3 servers (100, 200, 300 req/sec capacity), how to weight?</li>
                                <li>Design health check strategy: How often? What to check? Failover threshold?</li>
                                <li>Design GSLB for global application (3 data centers: US, EU, Asia)</li>
                                <li>Compare Layer 4 vs Layer 7 for different use cases</li>
                            </ul>

                            <h5>📖 Key Questions to Answer:</h5>
                            <ul class="resources-list">
                                <li>Which load balancing algorithm for long-lived connections? (Least Connections)</li>
                                <li>When to use consistent hashing? (Caching, distributed systems)</li>
                                <li>Layer 4 vs Layer 7 - when to use each?</li>
                                <li>How to handle server failures automatically?</li>
                                <li>Why are sticky sessions problematic?</li>
                                <li>How does global load balancing work?</li>
                                <li>What's the difference between active and passive health checks?</li>
                            </ul>
                        </div>
                    </div>

                    <!-- Day 9 -->
                    <div class="day-guide-card">
                        <div class="day-guide-header">
                            <span class="day-number-badge">Day 9</span>
                            <h4>API Gateway & Proxies</h4>
                        </div>

                        <div class="concepts-section">
                            <h5>🎯 Core Concepts to Learn:</h5>
                            <ul class="concepts-list">
                                <li><strong>What is API Gateway?</strong>
                                    <ul>
                                        <li>Single entry point for all client requests</li>
                                        <li>Sits between clients and microservices</li>
                                        <li>Reverse proxy with additional features</li>
                                        <li>Examples: Kong, AWS API Gateway, Apigee, Azure API Management</li>
                                    </ul>
                                </li>

                                <li><strong>API Gateway Responsibilities:</strong>
                                    <ul>
                                        <li><strong>Request Routing:</strong> Route /users to User Service, /products to
                                            Product Service</li>
                                        <li><strong>Authentication & Authorization:</strong> Verify JWT tokens, check
                                            permissions</li>
                                        <li><strong>Rate Limiting:</strong> Prevent abuse (e.g., 1000 requests/hour per
                                            user)</li>
                                        <li><strong>Request/Response Transformation:</strong> Convert XML to JSON,
                                            add/remove headers</li>
                                        <li><strong>Protocol Translation:</strong> HTTP to gRPC, REST to SOAP</li>
                                        <li><strong>API Composition:</strong> Aggregate multiple service calls into one
                                            response</li>
                                        <li><strong>Caching:</strong> Cache responses to reduce backend load</li>
                                        <li><strong>Logging & Monitoring:</strong> Centralized logging, metrics, tracing
                                        </li>
                                        <li><strong>SSL Termination:</strong> Handle HTTPS, forward HTTP to backend</li>
                                        <li><strong>Load Balancing:</strong> Distribute to multiple instances of service
                                        </li>
                                    </ul>
                                </li>

                                <li><strong>Reverse Proxy vs Forward Proxy:</strong>
                                    <ul>
                                        <li><strong>Forward Proxy:</strong> Client → Proxy → Internet
                                            <ul>
                                                <li>Hides client identity</li>
                                                <li>Examples: Corporate proxy, VPN</li>
                                                <li>Use case: Access blocked sites, anonymity</li>
                                            </ul>
                                        </li>
                                        <li><strong>Reverse Proxy:</strong> Client → Proxy → Backend Servers
                                            <ul>
                                                <li>Hides server identity</li>
                                                <li>Examples: Nginx, Apache, API Gateway</li>
                                                <li>Use case: Load balancing, security, caching</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>

                                <li><strong>Request Aggregation Pattern:</strong>
                                    <ul>
                                        <li>Problem: Mobile app needs data from 5 services → 5 requests (slow)</li>
                                        <li>Solution: API Gateway makes 5 requests, combines results, returns 1 response
                                        </li>
                                        <li>Benefits: Fewer round trips, less mobile bandwidth, simpler client</li>
                                        <li>Example: Product page needs: product info, reviews, recommendations,
                                            inventory</li>
                                        <li>Gateway fetches all in parallel, combines into single JSON response</li>
                                    </ul>
                                </li>

                                <li><strong>Backend for Frontend (BFF) Pattern:</strong>
                                    <ul>
                                        <li>Separate API gateway per client type</li>
                                        <li>Mobile BFF: Optimized for mobile (less data, combined calls)</li>
                                        <li>Web BFF: Optimized for web (more detailed data)</li>
                                        <li>Benefits: Tailor responses to each client, independent evolution</li>
                                        <li>Trade-off: More gateways to maintain</li>
                                    </ul>
                                </li>

                                <li><strong>Circuit Breaker Pattern (in Gateway):</strong>
                                    <ul>
                                        <li>Prevent cascade failures when service is down</li>
                                        <li>States: Closed (normal), Open (failing), Half-Open (testing recovery)</li>
                                        <li>If service fails N times → Open circuit → Return error immediately</li>
                                        <li>After timeout → Half-Open → Try request → Success? Close, Fail? Open</li>
                                        <li>Benefits: Fast failure, prevent overwhelming failing service</li>
                                    </ul>
                                </li>

                                <li><strong>API Gateway Challenges:</strong>
                                    <ul>
                                        <li><strong>Single Point of Failure:</strong> Gateway down = all APIs down
                                            <ul>
                                                <li>Solution: Multiple gateway instances with load balancer</li>
                                            </ul>
                                        </li>
                                        <li><strong>Bottleneck:</strong> All traffic through gateway
                                            <ul>
                                                <li>Solution: Scale horizontally, optimize gateway performance</li>
                                            </ul>
                                        </li>
                                        <li><strong>Latency:</strong> Extra hop adds latency
                                            <ul>
                                                <li>Solution: Keep gateway thin, use caching</li>
                                            </ul>
                                        </li>
                                        <li><strong>Complexity:</strong> Gateway becomes complex with many features
                                            <ul>
                                                <li>Solution: Keep gateway focused, push logic to services</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                            </ul>

                            <h5>💻 Practice Tasks:</h5>
                            <ul class="practice-list">
                                <li>Design API Gateway for e-commerce: What features needed?</li>
                                <li>Design request aggregation for mobile app (combine 5 service calls)</li>
                                <li>Design BFF pattern: Mobile vs Web vs IoT gateways</li>
                                <li>Implement circuit breaker logic (states and transitions)</li>
                                <li>Design authentication flow through gateway (JWT verification)</li>
                                <li>Design rate limiting strategy (per user, per IP, per API key)</li>
                                <li>Compare: When to use API Gateway vs Service Mesh?</li>
                            </ul>

                            <h5>📖 Key Questions to Answer:</h5>
                            <ul class="resources-list">
                                <li>What problems does API Gateway solve?</li>
                                <li>Forward proxy vs reverse proxy - what's the difference?</li>
                                <li>When to use BFF pattern?</li>
                                <li>How does circuit breaker prevent cascade failures?</li>
                                <li>What are disadvantages of API Gateway?</li>
                                <li>How to prevent gateway from becoming bottleneck?</li>
                                <li>Should business logic be in gateway? (No - keep thin)</li>
                            </ul>
                        </div>
                    </div>

                    <!-- Day 10 -->
                    <div class="day-guide-card">
                        <div class="day-guide-header">
                            <span class="day-number-badge">Day 10</span>
                            <h4>Rate Limiting & Throttling</h4>
                        </div>

                        <div class="concepts-section">
                            <h5>🎯 Core Concepts to Learn:</h5>
                            <ul class="concepts-list">
                                <li><strong>Why Rate Limiting?</strong>
                                    <ul>
                                        <li>Prevent abuse and DDoS attacks</li>
                                        <li>Ensure fair usage across users</li>
                                        <li>Control costs (API calls, resources)</li>
                                        <li>Protect backend services from overload</li>
                                        <li>Enforce SLA tiers (free vs paid users)</li>
                                    </ul>
                                </li>

                                <li><strong>Rate Limiting Algorithms:</strong>
                                    <ul>
                                        <li><strong>Token Bucket:</strong>
                                            <ul>
                                                <li>Bucket has tokens, each request consumes token</li>
                                                <li>Tokens refill at constant rate</li>
                                                <li>If bucket empty, reject request</li>
                                                <li>Allows bursts (accumulate tokens when idle)</li>
                                                <li>Example: 100 tokens, refill 10/second, max burst 100</li>
                                                <li>Used by: AWS, Stripe</li>
                                            </ul>
                                        </li>
                                        <li><strong>Leaky Bucket:</strong>
                                            <ul>
                                                <li>Requests enter bucket, processed at constant rate</li>
                                                <li>If bucket full, reject request</li>
                                                <li>Smooths bursts (enforces steady rate)</li>
                                                <li>Example: Process 10 requests/second, queue up to 100</li>
                                            </ul>
                                        </li>
                                        <li><strong>Fixed Window:</strong>
                                            <ul>
                                                <li>Allow N requests per time window (e.g., 100/minute)</li>
                                                <li>Counter resets at window boundary</li>
                                                <li>Simple but has boundary problem</li>
                                                <li>Problem: 100 at 12:59:59, 100 at 13:00:01 = 200 in 2 seconds!</li>
                                            </ul>
                                        </li>
                                        <li><strong>Sliding Window Log:</strong>
                                            <ul>
                                                <li>Store timestamp of each request</li>
                                                <li>Count requests in last N seconds</li>
                                                <li>Accurate but memory-intensive</li>
                                                <li>Example: Store all request timestamps in sorted set</li>
                                            </ul>
                                        </li>
                                        <li><strong>Sliding Window Counter:</strong>
                                            <ul>
                                                <li>Hybrid of fixed window and sliding log</li>
                                                <li>Weighted count from previous and current window</li>
                                                <li>More accurate than fixed, less memory than log</li>
                                                <li>Formula: PreviousCount × OverlapPercentage + CurrentCount</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>

                                <li><strong>Distributed Rate Limiting:</strong>
                                    <ul>
                                        <li>Challenge: Multiple API Gateway instances, need coordinated limit</li>
                                        <li><strong>Centralized (Redis):</strong>
                                            <ul>
                                                <li>Store counters in Redis (fast, shared state)</li>
                                                <li>All gateways check/increment same counter</li>
                                                <li>Accurate but Redis is single point</li>
                                                <li>Use Redis Cluster for availability</li>
                                            </ul>
                                        </li>
                                        <li><strong>Local + Sync:</strong>
                                            <ul>
                                                <li>Each gateway has local counter</li>
                                                <li>Periodically sync with central system</li>
                                                <li>Less accurate but more performant</li>
                                            </ul>
                                        </li>
                                        <li><strong>Gossip Protocol:</strong>
                                            <ul>
                                                <li>Gateways share state with each other</li>
                                                <li>Eventually consistent</li>
                                                <li>No central point of failure</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>

                                <li><strong>Rate Limit Headers:</strong>
                                    <ul>
                                        <li>Inform clients about limits</li>
                                        <li><strong>X-RateLimit-Limit:</strong> Max requests allowed</li>
                                        <li><strong>X-RateLimit-Remaining:</strong> Requests left in window</li>
                                        <li><strong>X-RateLimit-Reset:</strong> When limit resets (timestamp)</li>
                                        <li><strong>Retry-After:</strong> How long to wait if rate limited (429
                                            response)</li>
                                        <li>Example: X-RateLimit-Limit: 100, X-RateLimit-Remaining: 23,
                                            X-RateLimit-Reset: 1634567890</li>
                                    </ul>
                                </li>

                                <li><strong>Throttling Strategies:</strong>
                                    <ul>
                                        <li><strong>Hard Throttling:</strong> Reject requests over limit (return 429)
                                        </li>
                                        <li><strong>Soft Throttling:</strong> Allow brief bursts, then throttle</li>
                                        <li><strong>Dynamic Throttling:</strong> Adjust limits based on system load</li>
                                        <li><strong>Elastic Throttling:</strong> Allow temporary overages, track debt
                                        </li>
                                    </ul>
                                </li>

                                <li><strong>Different Limit Tiers:</strong>
                                    <ul>
                                        <li>Anonymous users: 10 requests/hour</li>
                                        <li>Free tier: 100 requests/hour</li>
                                        <li>Basic tier: 1,000 requests/hour</li>
                                        <li>Premium tier: 10,000 requests/hour</li>
                                        <li>Enterprise: Custom limits or no limits</li>
                                        <li>Per-API limits: Some APIs more expensive (e.g., search vs get by ID)</li>
                                    </ul>
                                </li>
                            </ul>

                            <h5>💻 Practice Tasks:</h5>
                            <ul class="practice-list">
                                <li>Implement token bucket algorithm (refill logic, consume tokens)</li>
                                <li>Compare algorithms: Which for steady rate? Which allows bursts?</li>
                                <li>Design distributed rate limiting with Redis</li>
                                <li>Handle race conditions (two gateways checking limit simultaneously)</li>
                                <li>Design rate limit for different tiers (free, basic, premium)</li>
                                <li>Calculate: User at 12:59:59 made 100 requests, at 13:00:01 makes 100 more - fixed
                                    window problem</li>
                                <li>Design dynamic throttling based on server CPU/memory</li>
                            </ul>

                            <h5>📖 Key Questions to Answer:</h5>
                            <ul class="resources-list">
                                <li>Token bucket vs leaky bucket - which allows bursts?</li>
                                <li>What's the boundary problem in fixed window?</li>
                                <li>How to implement rate limiting in distributed system?</li>
                                <li>What HTTP status code for rate limited? (429 Too Many Requests)</li>
                                <li>How to communicate rate limits to clients?</li>
                                <li>Where to implement rate limiting (gateway vs service)?</li>
                                <li>How to rate limit per user vs per IP?</li>
                            </ul>
                        </div>
                    </div>

                    <!-- Day 11 -->
                    <div class="day-guide-card">
                        <div class="day-guide-header">
                            <span class="day-number-badge">Day 11</span>
                            <h4>Message Queues & Async Processing</h4>
                        </div>

                        <div class="concepts-section">
                            <h5>🎯 Core Concepts to Learn:</h5>
                            <ul class="concepts-list">
                                <li><strong>Why Message Queues?</strong>
                                    <ul>
                                        <li>Decouple services (producer doesn't wait for consumer)</li>
                                        <li>Async processing (handle long tasks without blocking)</li>
                                        <li>Load leveling (smooth traffic spikes)</li>
                                        <li>Reliability (retry failed messages)</li>
                                        <li>Scalability (scale producers and consumers independently)</li>
                                    </ul>
                                </li>

                                <li><strong>Message Queue vs Pub/Sub:</strong>
                                    <ul>
                                        <li><strong>Message Queue (Point-to-Point):</strong>
                                            <ul>
                                                <li>One producer → Queue → One consumer</li>
                                                <li>Message consumed once (deleted after processing)</li>
                                                <li>Use case: Task distribution, job processing</li>
                                                <li>Example: RabbitMQ, AWS SQS, Azure Queue Storage</li>
                                            </ul>
                                        </li>
                                        <li><strong>Pub/Sub (Publish-Subscribe):</strong>
                                            <ul>
                                                <li>One publisher → Topic → Multiple subscribers</li>
                                                <li>Each subscriber gets copy of message</li>
                                                <li>Use case: Event notifications, broadcasting</li>
                                                <li>Example: Apache Kafka, AWS SNS, Google Pub/Sub</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>

                                <li><strong>Message Queue Patterns:</strong>
                                    <ul>
                                        <li><strong>Work Queue:</strong> Distribute tasks across workers
                                            <ul>
                                                <li>Multiple workers consume from same queue</li>
                                                <li>Each task processed by one worker</li>
                                                <li>Good for: Background jobs, email sending</li>
                                            </ul>
                                        </li>
                                        <li><strong>Priority Queue:</strong> Process important messages first
                                            <ul>
                                                <li>Messages have priority levels</li>
                                                <li>High priority processed before low priority</li>
                                                <li>Good for: Critical alerts, VIP customers</li>
                                            </ul>
                                        </li>
                                        <li><strong>Dead Letter Queue (DLQ):</strong> Store failed messages
                                            <ul>
                                                <li>After N retries, move to DLQ</li>
                                                <li>Investigate and fix issues</li>
                                                <li>Prevent blocking queue with poison messages</li>
                                            </ul>
                                        </li>
                                        <li><strong>Delayed Queue:</strong> Process message after delay
                                            <ul>
                                                <li>Schedule message for future processing</li>
                                                <li>Good for: Reminders, scheduled tasks</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>

                                <li><strong>Message Delivery Guarantees:</strong>
                                    <ul>
                                        <li><strong>At-most-once:</strong> Message delivered 0 or 1 time
                                            <ul>
                                                <li>May lose messages</li>
                                                <li>Fastest, lowest overhead</li>
                                                <li>Use when: Loss acceptable (metrics, logs)</li>
                                            </ul>
                                        </li>
                                        <li><strong>At-least-once:</strong> Message delivered 1 or more times
                                            <ul>
                                                <li>May have duplicates</li>
                                                <li>Good balance</li>
                                                <li>Consumer must be idempotent</li>
                                                <li>Most common choice</li>
                                            </ul>
                                        </li>
                                        <li><strong>Exactly-once:</strong> Message delivered exactly 1 time
                                            <ul>
                                                <li>No loss, no duplicates</li>
                                                <li>Complex and expensive</li>
                                                <li>Use when: Financial transactions</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>

                                <li><strong>Idempotency (Critical for At-Least-Once):</strong>
                                    <ul>
                                        <li>Process same message multiple times = same result</li>
                                        <li>Implementation: Use message ID to track processed messages</li>
                                        <li>Example: Payment processed twice → Check if payment_id already processed
                                        </li>
                                        <li>Storage: Redis or database to track message IDs</li>
                                    </ul>
                                </li>

                                <li><strong>Message Ordering:</strong>
                                    <ul>
                                        <li>Challenge: Multiple consumers process out of order</li>
                                        <li><strong>Solutions:</strong>
                                            <ul>
                                                <li>Single consumer: Guaranteed order but no parallelism</li>
                                                <li>Partition by key: Same key → same partition → same consumer</li>
                                                <li>Sequence numbers: Consumer reorders based on sequence</li>
                                            </ul>
                                        </li>
                                        <li>Kafka: Orders messages within partition</li>
                                    </ul>
                                </li>

                                <li><strong>Backpressure and Flow Control:</strong>
                                    <ul>
                                        <li>Problem: Producer too fast, overwhelms consumer</li>
                                        <li><strong>Solutions:</strong>
                                            <ul>
                                                <li>Queue size limit: Reject when full (push back to producer)</li>
                                                <li>Consumer prefetch: Limit messages pulled at once</li>
                                                <li>Rate limiting: Throttle producer</li>
                                                <li>Auto-scaling: Add more consumers when queue grows</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>

                                <li><strong>Use Cases:</strong>
                                    <ul>
                                        <li><strong>Async Processing:</strong> User uploads image → Queue → Process
                                            (resize, thumbnail)</li>
                                        <li><strong>Email Sending:</strong> User signs up → Queue → Send welcome email
                                        </li>
                                        <li><strong>Order Processing:</strong> Order placed → Queue → Validate, charge,
                                            ship</li>
                                        <li><strong>Log Aggregation:</strong> Services → Queue → Centralized logging
                                        </li>
                                        <li><strong>Event-driven:</strong> Order placed → Multiple subscribers
                                            (inventory, shipping, analytics)</li>
                                    </ul>
                                </li>
                            </ul>

                            <h5>💻 Practice Tasks:</h5>
                            <ul class="practice-list">
                                <li>Design image processing pipeline: Upload → Queue → Resize → Store</li>
                                <li>Design email sending system with retry and DLQ</li>
                                <li>Compare message queue vs pub/sub for different scenarios</li>
                                <li>Design order processing with idempotency (handle duplicate messages)</li>
                                <li>Design priority queue (VIP customers processed first)</li>
                                <li>Calculate: Queue with 10K messages/sec, consumer processes 1K/sec - how to scale?
                                </li>
                                <li>Design backpressure mechanism (queue size limit, consumer prefetch)</li>
                            </ul>

                            <h5>📖 Key Questions to Answer:</h5>
                            <ul class="resources-list">
                                <li>Message queue vs pub/sub - when to use each?</li>
                                <li>What's the difference between at-least-once and exactly-once?</li>
                                <li>Why is idempotency important?</li>
                                <li>How to ensure message ordering?</li>
                                <li>What is a dead letter queue and why needed?</li>
                                <li>How to handle backpressure (fast producer, slow consumer)?</li>
                                <li>When to use synchronous vs asynchronous communication?</li>
                            </ul>
                        </div>
                    </div>

                    <!-- Day 12 -->
                    <div class="day-guide-card">
                        <div class="day-guide-header">
                            <span class="day-number-badge">Day 12</span>
                            <h4>CDN & Static Content Delivery</h4>
                        </div>

                        <div class="concepts-section">
                            <h5>🎯 Core Concepts to Learn:</h5>
                            <ul class="concepts-list">
                                <li><strong>What is CDN (Content Delivery Network)?</strong>
                                    <ul>
                                        <li>Geographically distributed servers that cache content</li>
                                        <li>Serve content from location closest to user</li>
                                        <li>Components: Origin server, Edge servers (PoPs - Point of Presence)</li>
                                        <li>Examples: Cloudflare, Akamai, AWS CloudFront, Azure CDN</li>
                                    </ul>
                                </li>

                                <li><strong>Why Use CDN?</strong>
                                    <ul>
                                        <li><strong>Reduced Latency:</strong> Content closer to users (physical distance
                                            matters)</li>
                                        <li><strong>Lower Bandwidth Costs:</strong> Offload traffic from origin</li>
                                        <li><strong>High Availability:</strong> If one edge fails, route to another</li>
                                        <li><strong>DDoS Protection:</strong> Absorb malicious traffic at edge</li>
                                        <li><strong>Improved Performance:</strong> Faster page loads = better UX</li>
                                    </ul>
                                </li>

                                <li><strong>How CDN Works:</strong>
                                    <ul>
                                        <li><strong>First Request (Cache Miss):</strong>
                                            <ol>
                                                <li>User requests image.jpg</li>
                                                <li>DNS routes to nearest edge server</li>
                                                <li>Edge server doesn't have it (cache miss)</li>
                                                <li>Edge fetches from origin server</li>
                                                <li>Edge caches and serves to user</li>
                                            </ol>
                                        </li>
                                        <li><strong>Subsequent Requests (Cache Hit):</strong>
                                            <ol>
                                                <li>User requests same image.jpg</li>
                                                <li>Edge server has it (cache hit)</li>
                                                <li>Serve directly from cache (fast!)</li>
                                            </ol>
                                        </li>
                                    </ul>
                                </li>

                                <li><strong>CDN Caching Strategies:</strong>
                                    <ul>
                                        <li><strong>Static Content:</strong> Images, CSS, JavaScript, videos
                                            <ul>
                                                <li>Long TTL (Time To Live): Cache for days/weeks</li>
                                                <li>Immutable: Content never changes (use version in URL)</li>
                                            </ul>
                                        </li>
                                        <li><strong>Semi-Dynamic:</strong> Product pages, blog posts
                                            <ul>
                                                <li>Medium TTL: Cache for hours</li>
                                                <li>Purge on update</li>
                                            </ul>
                                        </li>
                                        <li><strong>Dynamic Content:</strong> User-specific data
                                            <ul>
                                                <li>Short TTL or no cache</li>
                                                <li>Can cache with user-specific key</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>

                                <li><strong>Cache Invalidation in CDN:</strong>
                                    <ul>
                                        <li><strong>TTL Expiration:</strong> Content expires after TTL
                                            <ul>
                                                <li>Simple but may serve stale content</li>
                                            </ul>
                                        </li>
                                        <li><strong>Purge/Invalidate:</strong> Manually remove from cache
                                            <ul>
                                                <li>Immediate but expensive operation</li>
                                                <li>Use when: Content updated, need fresh immediately</li>
                                            </ul>
                                        </li>
                                        <li><strong>Versioned URLs:</strong> Change URL when content changes
                                            <ul>
                                                <li>style.v1.css → style.v2.css</li>
                                                <li>Or hash: style.a1b2c3.css</li>
                                                <li>Best practice: Infinite TTL, never invalidate</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>

                                <li><strong>Push vs Pull CDN:</strong>
                                    <ul>
                                        <li><strong>Push CDN:</strong>
                                            <ul>
                                                <li>You upload content to CDN proactively</li>
                                                <li>Good for: Small amount of content, infrequent changes</li>
                                                <li>Full control over what's cached</li>
                                            </ul>
                                        </li>
                                        <li><strong>Pull CDN:</strong>
                                            <ul>
                                                <li>CDN fetches from origin when requested (lazy loading)</li>
                                                <li>Good for: Large amount of content, frequent changes</li>
                                                <li>Easier to set up (just point CDN to origin)</li>
                                                <li>Most common approach</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>

                                <li><strong>CDN Features:</strong>
                                    <ul>
                                        <li><strong>Geo-blocking:</strong> Restrict content by country</li>
                                        <li><strong>Token Authentication:</strong> Signed URLs for private content</li>
                                        <li><strong>Image Optimization:</strong> Auto-resize, format conversion (WebP)
                                        </li>
                                        <li><strong>Compression:</strong> Gzip, Brotli for smaller files</li>
                                        <li><strong>HTTP/2, HTTP/3:</strong> Modern protocols for faster delivery</li>
                                        <li><strong>SSL/TLS:</strong> Secure content delivery</li>
                                        <li><strong>DDoS Protection:</strong> Absorb and filter attacks</li>
                                        <li><strong>Web Application Firewall (WAF):</strong> Filter malicious requests
                                        </li>
                                    </ul>
                                </li>

                                <li><strong>When NOT to Use CDN:</strong>
                                    <ul>
                                        <li>Highly dynamic, user-specific content (personalized dashboard)</li>
                                        <li>Content that changes constantly (live stock prices)</li>
                                        <li>Small, regional application (all users in one city)</li>
                                        <li>Internal applications (not internet-facing)</li>
                                    </ul>
                                </li>
                            </ul>

                            <h5>💻 Practice Tasks:</h5>
                            <ul class="practice-list">
                                <li>Design CDN strategy for e-commerce site (what to cache, TTL for each)</li>
                                <li>Compare push vs pull CDN for different use cases</li>
                                <li>Design cache invalidation strategy (versioned URLs vs purge)</li>
                                <li>Calculate bandwidth savings: 10M users, 1 MB page, 80% cache hit rate</li>
                                <li>Design CDN for video streaming (large files, millions of users)</li>
                                <li>Design content delivery for global news site (fast updates, worldwide users)</li>
                                <li>Design signed URLs for private content (S3 + CloudFront)</li>
                            </ul>

                            <h5>📖 Key Questions to Answer:</h5>
                            <ul class="resources-list">
                                <li>How does CDN reduce latency?</li>
                                <li>What's the difference between cache hit and cache miss?</li>
                                <li>Push CDN vs Pull CDN - when to use each?</li>
                                <li>How to invalidate CDN cache?</li>
                                <li>What content should be cached in CDN?</li>
                                <li>Why use versioned URLs instead of cache purging?</li>
                                <li>How does CDN help with DDoS attacks?</li>
                            </ul>
                        </div>
                    </div>

                    <!-- Day 13 -->
                    <div class="day-guide-card">
                        <div class="day-guide-header">
                            <span class="day-number-badge">Day 13</span>
                            <h4>Security Fundamentals</h4>
                        </div>

                        <div class="concepts-section">
                            <h5>🎯 Core Concepts to Learn:</h5>
                            <ul class="concepts-list">
                                <li><strong>Authentication vs Authorization:</strong>
                                    <ul>
                                        <li><strong>Authentication:</strong> Who are you? (Identity verification)
                                            <ul>
                                                <li>Methods: Password, OAuth, SAML, Biometric</li>
                                                <li>Example: Login with username/password</li>
                                            </ul>
                                        </li>
                                        <li><strong>Authorization:</strong> What can you do? (Permission checking)
                                            <ul>
                                                <li>Happens after authentication</li>
                                                <li>Example: Admin can delete users, regular user cannot</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>

                                <li><strong>Session-based vs Token-based Authentication:</strong>
                                    <ul>
                                        <li><strong>Session-based (Stateful):</strong>
                                            <ul>
                                                <li>Server stores session in memory/database</li>
                                                <li>Client gets session ID in cookie</li>
                                                <li>Pros: Easy to revoke, server controls</li>
                                                <li>Cons: Hard to scale (need shared session store), CSRF vulnerable
                                                </li>
                                            </ul>
                                        </li>
                                        <li><strong>Token-based (Stateless):</strong>
                                            <ul>
                                                <li>Server issues signed token (JWT)</li>
                                                <li>Client includes token in header</li>
                                                <li>Pros: Scalable (no server-side storage), works across domains</li>
                                                <li>Cons: Hard to revoke, token size larger</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>

                                <li><strong>JWT (JSON Web Token):</strong>
                                    <ul>
                                        <li>Structure: Header.Payload.Signature</li>
                                        <li><strong>Header:</strong> Algorithm and token type
                                            {"alg":"HS256","typ":"JWT"}</li>
                                        <li><strong>Payload:</strong> Claims (user data)
                                            {"userId":"123","role":"admin","exp":1234567890}</li>
                                        <li><strong>Signature:</strong> HMAC(base64(header) + "." + base64(payload),
                                            secret)</li>
                                        <li>Benefits: Stateless, compact, can contain user data</li>
                                        <li>Security: Never store sensitive data in JWT (it's base64, not encrypted!)
                                        </li>
                                        <li>Expiration: Set exp claim (e.g., 15 minutes)</li>
                                        <li>Refresh tokens: Long-lived token to get new access token</li>
                                    </ul>
                                </li>

                                <li><strong>OAuth 2.0 Flow:</strong>
                                    <ul>
                                        <li>Standard for authorization (used by Google, Facebook, GitHub)</li>
                                        <li><strong>Authorization Code Flow (most common):</strong>
                                            <ol>
                                                <li>User clicks "Login with Google"</li>
                                                <li>Redirect to Google login</li>
                                                <li>User logs in, approves permissions</li>
                                                <li>Google redirects back with authorization code</li>
                                                <li>Your server exchanges code for access token</li>
                                                <li>Use access token to call Google APIs</li>
                                            </ol>
                                        </li>
                                        <li>Roles: Resource Owner (user), Client (your app), Authorization Server
                                            (Google), Resource Server (Google APIs)</li>
                                        <li>Benefits: No password sharing, granular permissions, revocable access</li>
                                    </ul>
                                </li>

                                <li><strong>Common Security Vulnerabilities:</strong>
                                    <ul>
                                        <li><strong>SQL Injection:</strong>
                                            <ul>
                                                <li>Attack: Inject SQL in input field</li>
                                                <li>Example: username = "admin' OR '1'='1"</li>
                                                <li>Prevention: Use parameterized queries, never concatenate SQL</li>
                                            </ul>
                                        </li>
                                        <li><strong>XSS (Cross-Site Scripting):</strong>
                                            <ul>
                                                <li>Attack: Inject JavaScript in user input</li>
                                                <li>Example: Comment contains
                                                    &lt;script&gt;alert('hacked')&lt;/script&gt;</li>
                                                <li>Prevention: Escape HTML, Content Security Policy</li>
                                            </ul>
                                        </li>
                                        <li><strong>CSRF (Cross-Site Request Forgery):</strong>
                                            <ul>
                                                <li>Attack: Trick user into making unwanted request</li>
                                                <li>Example: Evil site triggers delete account on your site</li>
                                                <li>Prevention: CSRF tokens, SameSite cookies</li>
                                            </ul>
                                        </li>
                                        <li><strong>DDoS (Distributed Denial of Service):</strong>
                                            <ul>
                                                <li>Attack: Overwhelm server with requests</li>
                                                <li>Prevention: Rate limiting, CDN, DDoS protection service</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>

                                <li><strong>Encryption Basics:</strong>
                                    <ul>
                                        <li><strong>Encryption in Transit:</strong> HTTPS/TLS
                                            <ul>
                                                <li>Protect data while traveling over network</li>
                                                <li>SSL/TLS certificates</li>
                                            </ul>
                                        </li>
                                        <li><strong>Encryption at Rest:</strong> Database/disk encryption
                                            <ul>
                                                <li>Protect data stored on disk</li>
                                                <li>Even if disk stolen, data unreadable</li>
                                            </ul>
                                        </li>
                                        <li><strong>Hashing vs Encryption:</strong>
                                            <ul>
                                                <li>Hashing: One-way (can't decrypt) - for passwords</li>
                                                <li>Encryption: Two-way (can decrypt) - for sensitive data</li>
                                            </ul>
                                        </li>
                                        <li><strong>Password Hashing:</strong>
                                            <ul>
                                                <li>Never store plain text passwords!</li>
                                                <li>Use: bcrypt, scrypt, Argon2 (slow hashes with salt)</li>
                                                <li>Salt: Random string added to password before hashing</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>

                                <li><strong>HTTPS and TLS:</strong>
                                    <ul>
                                        <li>TLS: Encrypts communication between client and server</li>
                                        <li>Certificate: Proves server identity (issued by Certificate Authority)</li>
                                        <li>Handshake: Client and server agree on encryption method</li>
                                        <li>Benefits: Privacy, integrity, authentication</li>
                                        <li>Let's Encrypt: Free SSL certificates</li>
                                    </ul>
                                </li>

                                <li><strong>API Security Best Practices:</strong>
                                    <ul>
                                        <li>Use HTTPS always (never HTTP for sensitive data)</li>
                                        <li>Implement authentication (OAuth, JWT)</li>
                                        <li>Use rate limiting (prevent abuse)</li>
                                        <li>Validate all inputs (prevent injection attacks)</li>
                                        <li>Use CORS properly (restrict cross-origin requests)</li>
                                        <li>Log security events (authentication failures, suspicious activity)</li>
                                        <li>Keep dependencies updated (patch vulnerabilities)</li>
                                        <li>Implement API keys or tokens (track usage)</li>
                                    </ul>
                                </li>
                            </ul>

                            <h5>💻 Practice Tasks:</h5>
                            <ul class="practice-list">
                                <li>Design authentication flow: Login → JWT → Refresh token</li>
                                <li>Design OAuth 2.0 flow for "Login with Google"</li>
                                <li>Compare session-based vs token-based auth for different scenarios</li>
                                <li>Design password reset flow (secure token, expiration)</li>
                                <li>Design API security: Rate limiting, authentication, input validation</li>
                                <li>Design protection against common attacks (SQL injection, XSS, CSRF)</li>
                                <li>Design encryption strategy: What to encrypt in transit vs at rest</li>
                            </ul>

                            <h5>📖 Key Questions to Answer:</h5>
                            <ul class="resources-list">
                                <li>Authentication vs authorization - what's the difference?</li>
                                <li>Session-based vs token-based auth - when to use each?</li>
                                <li>How does JWT work and what's in it?</li>
                                <li>What is OAuth 2.0 and when to use it?</li>
                                <li>How to protect against SQL injection?</li>
                                <li>What's the difference between hashing and encryption?</li>
                                <li>Why use HTTPS? What does TLS provide?</li>
                                <li>How to store passwords securely?</li>
                            </ul>
                        </div>
                    </div>

                    <!-- Day 14 -->
                    <div class="day-guide-card">
                        <div class="day-guide-header">
                            <span class="day-number-badge">Day 14</span>
                            <h4>Week 2 Review & Mini Project</h4>
                        </div>

                        <div class="concepts-section">
                            <h5>🎯 Week 2 Review Checklist:</h5>
                            <ul class="concepts-list">
                                <li><strong>Load Balancing (Day 8):</strong>
                                    <ul>
                                        <li>Can explain different load balancing algorithms?</li>
                                        <li>Know when to use Round Robin vs Least Connections?</li>
                                        <li>Understand Layer 4 vs Layer 7 load balancing?</li>
                                        <li>Know how to implement health checks?</li>
                                        <li>Understand consistent hashing?</li>
                                    </ul>
                                </li>

                                <li><strong>API Gateway (Day 9):</strong>
                                    <ul>
                                        <li>Can explain API Gateway responsibilities?</li>
                                        <li>Understand reverse proxy vs forward proxy?</li>
                                        <li>Know when to use BFF pattern?</li>
                                        <li>Can explain circuit breaker pattern?</li>
                                        <li>Understand request aggregation?</li>
                                    </ul>
                                </li>

                                <li><strong>Rate Limiting (Day 10):</strong>
                                    <ul>
                                        <li>Can compare different rate limiting algorithms?</li>
                                        <li>Understand token bucket vs leaky bucket?</li>
                                        <li>Know how to implement distributed rate limiting?</li>
                                        <li>Understand rate limit headers?</li>
                                    </ul>
                                </li>

                                <li><strong>Message Queues (Day 11):</strong>
                                    <ul>
                                        <li>Understand message queue vs pub/sub?</li>
                                        <li>Know different delivery guarantees?</li>
                                        <li>Understand idempotency?</li>
                                        <li>Can explain dead letter queue?</li>
                                        <li>Know how to handle backpressure?</li>
                                    </ul>
                                </li>

                                <li><strong>CDN (Day 12):</strong>
                                    <ul>
                                        <li>Can explain how CDN works?</li>
                                        <li>Understand cache invalidation strategies?</li>
                                        <li>Know push vs pull CDN?</li>
                                        <li>Understand versioned URLs?</li>
                                    </ul>
                                </li>

                                <li><strong>Security (Day 13):</strong>
                                    <ul>
                                        <li>Understand authentication vs authorization?</li>
                                        <li>Know session-based vs token-based auth?</li>
                                        <li>Can explain JWT and OAuth 2.0?</li>
                                        <li>Know common security vulnerabilities?</li>
                                        <li>Understand encryption basics?</li>
                                    </ul>
                                </li>
                            </ul>

                            <h5>💻 Mini Project: Design API Infrastructure</h5>
                            <ul class="practice-list">
                                <li><strong>Scenario:</strong> Design complete API infrastructure for e-commerce
                                    platform
                                    <ul>
                                        <li>Expected traffic: 10,000 requests/second</li>
                                        <li>Need: High availability, security, scalability</li>
                                    </ul>
                                </li>

                                <li><strong>Requirements to Address:</strong>
                                    <ol>
                                        <li><strong>Load Balancing:</strong>
                                            <ul>
                                                <li>Choose algorithm (consider checkout vs browsing)</li>
                                                <li>Layer 4 or Layer 7?</li>
                                                <li>Health check strategy</li>
                                            </ul>
                                        </li>
                                        <li><strong>API Gateway:</strong>
                                            <ul>
                                                <li>Authentication (JWT)</li>
                                                <li>Rate limiting (free tier: 100/hour, premium: 10,000/hour)</li>
                                                <li>Request routing (/users → User Service, /products → Product Service)
                                                </li>
                                                <li>Circuit breaker for failing services</li>
                                            </ul>
                                        </li>
                                        <li><strong>Async Processing:</strong>
                                            <ul>
                                                <li>Order placed → Message queue → Process payment, update inventory,
                                                    send email</li>
                                                <li>Choose message queue vs pub/sub</li>
                                                <li>Implement retry and DLQ</li>
                                            </ul>
                                        </li>
                                        <li><strong>CDN:</strong>
                                            <ul>
                                                <li>What to cache? (Product images, CSS, JavaScript)</li>
                                                <li>TTL strategy</li>
                                                <li>Cache invalidation</li>
                                            </ul>
                                        </li>
                                        <li><strong>Security:</strong>
                                            <ul>
                                                <li>Authentication flow (login, JWT, refresh tokens)</li>
                                                <li>HTTPS everywhere</li>
                                                <li>Input validation</li>
                                                <li>Protection against DDoS, SQL injection</li>
                                            </ul>
                                        </li>
                                    </ol>
                                </li>

                                <li><strong>Draw Architecture Diagram:</strong>
                                    <ul>
                                        <li>Client → CDN → Load Balancer → API Gateway → Microservices</li>
                                        <li>Message Queue for async tasks</li>
                                        <li>Security components at each layer</li>
                                    </ul>
                                </li>

                                <li><strong>Document Trade-offs:</strong>
                                    <ul>
                                        <li>Why this load balancing algorithm?</li>
                                        <li>Why Layer 7 over Layer 4 (or vice versa)?</li>
                                        <li>Why message queue instead of direct calls?</li>
                                        <li>Why JWT instead of session-based auth?</li>
                                    </ul>
                                </li>
                            </ul>

                            <h5>📖 Key Takeaways from Week 2:</h5>
                            <ul class="resources-list">
                                <li>Load balancers distribute traffic and enable horizontal scaling</li>
                                <li>API Gateway centralizes cross-cutting concerns (auth, rate limiting, routing)</li>
                                <li>Rate limiting protects against abuse and ensures fair usage</li>
                                <li>Message queues decouple services and enable async processing</li>
                                <li>CDN reduces latency and bandwidth costs for static content</li>
                                <li>Security must be implemented at every layer</li>
                                <li>Always consider trade-offs when choosing technologies</li>
                            </ul>

                        </div>
                    </div>
                </div>

                <!-- Week 3: Distributed Systems & Advanced Patterns (Days 15-21) -->
                <div class="study-guide-week">
                    <h3 class="week-header-guide">Week 3: Distributed Systems & Advanced Patterns (Days 15-21)</h3>

                    <!-- Day 15 -->
                    <div class="day-guide-card">
                        <div class="day-guide-header">
                            <span class="day-number-badge">Day 15</span>
                            <h4>CAP Theorem & Trade-off Analysis</h4>
                        </div>

                        <div class="concepts-section">
                            <h5>🎯 Core Concepts to Learn:</h5>
                            <ul class="concepts-list">
                                <li><strong>CAP Theorem Fundamentals:</strong>
                                    <ul>
                                        <li><strong>Consistency:</strong> All nodes see same data at same time</li>
                                        <li><strong>Availability:</strong> Every request receives response (success or
                                            failure)</li>
                                        <li><strong>Partition Tolerance:</strong> System continues despite network
                                            failures</li>
                                        <li>Reality: Can only guarantee 2 of 3 properties</li>
                                        <li>Partition tolerance is NOT optional (networks WILL fail)</li>
                                        <li>Real choice: CP (Consistent + Partition Tolerant) vs AP (Available +
                                            Partition Tolerant)</li>
                                    </ul>
                                </li>

                                <li><strong>CP Systems (Choose Consistency):</strong>
                                    <ul>
                                        <li>When partition occurs: Reject requests to maintain consistency</li>
                                        <li>Examples: Banking systems, HBase, MongoDB (strong consistency), Redis
                                            (single master)</li>
                                        <li>Use cases: Financial transactions, inventory management, booking systems
                                        </li>
                                        <li>Trade-off: Sacrifice availability during partitions</li>
                                    </ul>
                                </li>

                                <li><strong>AP Systems (Choose Availability):</strong>
                                    <ul>
                                        <li>When partition occurs: Accept requests, allow temporary inconsistencies</li>
                                        <li>Examples: Cassandra, DynamoDB, Riak, DNS, Social media</li>
                                        <li>Use cases: Social media likes/views, analytics, caching, content delivery
                                        </li>
                                        <li>Trade-off: Sacrifice consistency for uptime</li>
                                    </ul>
                                </li>

                                <li><strong>Consistency Models (Spectrum):</strong>
                                    <ul>
                                        <li><strong>Strong Consistency:</strong> Once write completes, all reads return
                                            that value (like single copy)</li>
                                        <li><strong>Sequential Consistency:</strong> Operations appear in order for each
                                            client</li>
                                        <li><strong>Causal Consistency:</strong> Causally related operations seen in
                                            order</li>
                                        <li><strong>Eventual Consistency:</strong> Given enough time, all replicas
                                            converge</li>
                                        <li><strong>Read-Your-Writes:</strong> User sees their own writes immediately
                                        </li>
                                    </ul>
                                </li>

                                <li><strong>Trade-off Analysis Framework:</strong>
                                    <ul>
                                        <li><strong>Consistency vs Availability:</strong> Reject requests vs accept with
                                            stale data</li>
                                        <li><strong>Consistency vs Latency:</strong> Wait for replicas vs respond
                                            immediately</li>
                                        <li><strong>Latency vs Throughput:</strong> Single request speed vs total
                                            capacity</li>
                                        <li><strong>Durability vs Performance:</strong> Write to disk vs memory</li>
                                        <li><strong>Cost vs Performance:</strong> More servers vs slower responses</li>
                                        <li><strong>Simplicity vs Scalability:</strong> Monolith vs microservices</li>
                                        <li><strong>Normalization vs Denormalization:</strong> Less redundancy vs faster
                                            reads</li>
                                        <li><strong>Strong Schema vs Flexible:</strong> SQL vs NoSQL</li>
                                    </ul>
                                </li>
                            </ul>

                            <h5>💻 Practice Tasks:</h5>
                            <ul class="practice-list">
                                <li>Analyze Twitter components: Which should be CP vs AP? (Tweets, Follows, DMs, Likes)
                                </li>
                                <li>Analyze Instagram components: Photo uploads, Likes counter, Comments, User feed</li>
                                <li>Analyze Banking system: Account balance, Transaction history, ATM withdrawals</li>
                                <li>Create decision tree for choosing CAP approach based on requirements</li>
                                <li>Build comparison table: Google Docs vs Facebook vs Stripe vs YouTube</li>
                                <li>Cost-performance analysis for different server configurations</li>
                                <li>Document trade-offs for real system (Uber, Airbnb, or Netflix)</li>
                            </ul>

                            <h5>📖 Key Questions to Answer:</h5>
                            <ul class="resources-list">
                                <li>Why is partition tolerance not optional in distributed systems?</li>
                                <li>Can you have both strong consistency AND high availability?</li>
                                <li>How does DNS prioritize availability over consistency?</li>
                                <li>What's the difference between linearizability and serializability?</li>
                                <li>When would you choose eventual consistency for banking feature?</li>
                                <li>What are hidden costs of strong consistency?</li>
                                <li>How to handle conflicts in eventual consistency systems?</li>
                            </ul>
                        </div>
                    </div>

                    <!-- Day 16 -->
                    <div class="day-guide-card">
                        <div class="day-guide-header">
                            <span class="day-number-badge">Day 16</span>
                            <h4>Distributed Transactions</h4>
                        </div>

                        <div class="concepts-section">
                            <h5>🎯 Core Concepts to Learn:</h5>
                            <ul class="concepts-list">
                                <li><strong>The Distributed Transaction Problem:</strong>
                                    <ul>
                                        <li>Challenge: Atomic operations across multiple nodes</li>
                                        <li>Example: Transfer $100 from Account A to Account B (different databases)
                                        </li>
                                        <li>What if one succeeds and other fails?</li>
                                        <li>ACID harder in distributed systems</li>
                                    </ul>
                                </li>

                                <li><strong>Two-Phase Commit (2PC):</strong>
                                    <ul>
                                        <li><strong>Phase 1 - Prepare:</strong> Coordinator asks all participants "Can
                                            you commit?"</li>
                                        <li>Participants lock resources and respond YES or NO</li>
                                        <li><strong>Phase 2 - Commit/Abort:</strong> If all YES, commit; if any NO,
                                            abort</li>
                                        <li><strong>Pros:</strong> Guarantees atomicity, prevents inconsistent states
                                        </li>
                                        <li><strong>Cons:</strong> Blocking (holds locks), single point of failure,
                                            slow, not partition-tolerant</li>
                                        <li>Failure scenarios: Participant fails, coordinator fails, network partition
                                        </li>
                                    </ul>
                                </li>

                                <li><strong>Three-Phase Commit (3PC):</strong>
                                    <ul>
                                        <li>Adds "pre-commit" phase to reduce blocking</li>
                                        <li>Phases: Can-Commit → Pre-Commit → Do-Commit</li>
                                        <li>Benefit: Participants can timeout and decide</li>
                                        <li>Drawback: Still slow, rarely used in practice</li>
                                    </ul>
                                </li>

                                <li><strong>Saga Pattern (Modern Approach):</strong>
                                    <ul>
                                        <li>Philosophy: Break transaction into sequence of local transactions</li>
                                        <li>Each step has compensating action (undo)</li>
                                        <li>No locks held across services</li>
                                        <li><strong>Choreography (Event-Based):</strong> Each service publishes events,
                                            next reacts</li>
                                        <li><strong>Orchestration (Coordinator):</strong> Central orchestrator calls
                                            each service</li>
                                        <li><strong>Compensation Actions:</strong> Not rollback - compensate for
                                            external effects</li>
                                        <li>Examples: Refund charge, release inventory, cancel shipment</li>
                                    </ul>
                                </li>

                                <li><strong>Saga: Choreography vs Orchestration:</strong>
                                    <ul>
                                        <li><strong>Choreography Pros:</strong> No single point of failure, loosely
                                            coupled, easy to add services</li>
                                        <li><strong>Choreography Cons:</strong> Hard to understand flow, difficult to
                                            debug, no central monitoring</li>
                                        <li><strong>Orchestration Pros:</strong> Clear flow, easy to monitor,
                                            centralized error handling</li>
                                        <li><strong>Orchestration Cons:</strong> Orchestrator is SPOF, becomes complex,
                                            services coupled</li>
                                        <li>When to use each: Choreography for simple flows, Orchestration for complex
                                            flows</li>
                                    </ul>
                                </li>

                                <li><strong>Idempotency (Critical Concept):</strong>
                                    <ul>
                                        <li>Definition: Operation produces same result if done once or multiple times
                                        </li>
                                        <li>Why important: Network failures cause retries</li>
                                        <li>Examples: PUT and DELETE are idempotent, POST is not</li>
                                        <li>Implementation: Use unique request IDs, check if already processed</li>
                                        <li>Payment example: Check payment_id before charging again</li>
                                    </ul>
                                </li>
                            </ul>

                            <h5>💻 Practice Tasks:</h5>
                            <ul class="practice-list">
                                <li>Design 2PC protocol with timeout handling and recovery</li>
                                <li>Design Saga for order processing (both choreography and orchestration styles)</li>
                                <li>Implement idempotent payment API with request ID tracking</li>
                                <li>Compare 2PC vs Saga: Create table with atomicity, blocking, performance,
                                    availability</li>
                                <li>Design banking transfer with Saga (handle all failure scenarios)</li>
                                <li>Analyze what happens if compensation action fails</li>
                            </ul>

                            <h5>📖 Key Questions to Answer:</h5>
                            <ul class="resources-list">
                                <li>Why is 2PC rarely used in microservices?</li>
                                <li>What happens if compensation action fails in Saga?</li>
                                <li>How do you ensure idempotency in distributed systems?</li>
                                <li>Choreography vs Orchestration - which is better?</li>
                                <li>Can Saga provide ACID guarantees? (No - only eventual consistency)</li>
                                <li>How to handle "lost message" in choreographed Saga?</li>
                                <li>What's difference between rollback and compensation?</li>
                            </ul>
                        </div>
                    </div>

                    <!-- Day 17 -->
                    <div class="day-guide-card">
                        <div class="day-guide-header">
                            <span class="day-number-badge">Day 17</span>
                            <h4>Replication & Consensus</h4>
                        </div>

                        <div class="concepts-section">
                            <h5>🎯 Core Concepts to Learn:</h5>
                            <ul class="concepts-list">
                                <li><strong>Why Replication?</strong>
                                    <ul>
                                        <li>High availability: If one node fails, others serve requests</li>
                                        <li>Fault tolerance: Survive node crashes</li>
                                        <li>Read scalability: Distribute read load</li>
                                        <li>Geographic distribution: Low latency for users worldwide</li>
                                        <li>Disaster recovery: Backup in different data centers</li>
                                    </ul>
                                </li>

                                <li><strong>Leader Election:</strong>
                                    <ul>
                                        <li>Problem: Who decides who's in charge in distributed system?</li>
                                        <li>Requirements: At most one leader, system eventually elects leader, all nodes
                                            agree</li>
                                        <li><strong>Bully Algorithm:</strong> Node with highest ID becomes leader
                                            (simple but flawed)</li>
                                        <li><strong>Raft Leader Election:</strong> Candidates request votes, majority
                                            wins, uses term numbers</li>
                                        <li>Heartbeats: Leader sends periodic messages to maintain authority</li>
                                    </ul>
                                </li>

                                <li><strong>Paxos Consensus:</strong>
                                    <ul>
                                        <li>The gold standard but complex</li>
                                        <li>Problem: How do distributed nodes agree on single value?</li>
                                        <li>Roles: Proposer (proposes values), Acceptor (votes), Learner (learns chosen
                                            value)</li>
                                        <li>Two phases: Prepare (ask if will accept) and Accept (send actual value)</li>
                                        <li>Key insight: Use proposal numbers to order operations</li>
                                        <li>Reality: Very complex to implement, most use Raft instead</li>
                                    </ul>
                                </li>

                                <li><strong>Raft Consensus:</strong>
                                    <ul>
                                        <li>Goal: Same guarantees as Paxos, easier to understand</li>
                                        <li><strong>Leader Election:</strong> Followers elect leader via voting</li>
                                        <li><strong>Log Replication:</strong> Leader manages log, replicates to
                                            followers</li>
                                        <li><strong>Terms:</strong> Logical time periods with one leader</li>
                                        <li><strong>Safety Guarantees:</strong> Election safety, log matching, leader
                                            completeness</li>
                                        <li>Handles network partitions gracefully with majority rule</li>
                                        <li>Used by: etcd, Consul, CockroachDB, TiDB</li>
                                    </ul>
                                </li>

                                <li><strong>Quorum Reads and Writes:</strong>
                                    <ul>
                                        <li>Quorum: Majority of nodes (N/2 + 1)</li>
                                        <li>Write Quorum (W): Must write to W nodes</li>
                                        <li>Read Quorum (R): Must read from R nodes</li>
                                        <li>Guarantee: If R + W > N, reads always see latest write</li>
                                        <li>Example (5 nodes): W=3, R=3, R+W=6>5 ✓</li>
                                        <li>Configurations: Strong consistency (R+W>N), Read-optimized (R=1, W=N),
                                            Write-optimized (R=N, W=1)</li>
                                        <li>Sloppy quorums: Write to temporary nodes if primary unavailable</li>
                                    </ul>
                                </li>

                                <li><strong>Replication Strategies:</strong>
                                    <ul>
                                        <li><strong>Single-Leader:</strong> One master writes, replicas read (simple,
                                            consistent)</li>
                                        <li><strong>Multi-Leader:</strong> Multiple masters write (better performance,
                                            need conflict resolution)</li>
                                        <li><strong>Leaderless:</strong> All nodes equal, use quorums (high
                                            availability, complex conflicts)</li>
                                    </ul>
                                </li>
                            </ul>

                            <h5>💻 Practice Tasks:</h5>
                            <ul class="practice-list">
                                <li>Simulate Raft leader election with 5 nodes</li>
                                <li>Test node failures and verify only one leader elected</li>
                                <li>Simulate network partitions in Raft cluster</li>
                                <li>Implement quorum system: Test with N=5, W=3, R=3</li>
                                <li>Verify system works with 2 nodes down</li>
                                <li>Compare different quorum configurations (W=5,R=1 vs W=3,R=3)</li>
                                <li>Design consensus-based configuration system using Raft</li>
                                <li>Analyze split-brain scenarios: 5 nodes split into [3] and [2]</li>
                            </ul>

                            <h5>📖 Key Questions to Answer:</h5>
                            <ul class="resources-list">
                                <li>Why do we need consensus in distributed systems?</li>
                                <li>What's the difference between Paxos and Raft?</li>
                                <li>Can 4-node cluster tolerate 2 failures? (No, needs quorum of 3)</li>
                                <li>Why are odd numbers of nodes preferred?</li>
                                <li>How does Raft prevent split-brain?</li>
                                <li>What happens if leader and one follower partition from others?</li>
                                <li>How many nodes needed for fault tolerance of F failures? (2F + 1)</li>
                            </ul>
                        </div>
                    </div>

                    <!-- Day 18 -->
                    <div class="day-guide-card">
                        <div class="day-guide-header">
                            <span class="day-number-badge">Day 18</span>
                            <h4>Microservices & Capacity Planning</h4>
                        </div>

                        <div class="concepts-section">
                            <h5>🎯 Core Concepts to Learn:</h5>
                            <ul class="concepts-list">
                                <li><strong>Microservices Architecture:</strong>
                                    <ul>
                                        <li>Small, independent services</li>
                                        <li>Each service owns its data</li>
                                        <li>Communicate via APIs (REST, gRPC, message queues)</li>
                                        <li>Can be deployed independently</li>
                                    </ul>
                                </li>

                                <li><strong>Monolith vs Microservices:</strong>
                                    <ul>
                                        <li><strong>Monolith Pros:</strong> Simple development, easy testing, good
                                            performance</li>
                                        <li><strong>Monolith Cons:</strong> Hard to scale, long build times, technology
                                            lock-in</li>
                                        <li><strong>Microservices Pros:</strong> Scalable, technology flexibility, fault
                                            isolation</li>
                                        <li><strong>Microservices Cons:</strong> Complex, network latency, data
                                            consistency issues</li>
                                        <li><strong>When microservices:</strong> Team > 10-15, need different scaling,
                                            frequent deployments</li>
                                        <li><strong>When monolith:</strong> Small team, early stage, simple app, start
                                            simple!</li>
                                    </ul>
                                </li>

                                <li><strong>Service Boundaries (Domain-Driven Design):</strong>
                                    <ul>
                                        <li>Bounded Context: Each service owns a domain</li>
                                        <li>E-commerce example: User, Catalog, Cart, Order, Payment, Inventory,
                                            Notification services</li>
                                        <li>Define by: Business capabilities, data ownership, change frequency, team
                                            structure</li>
                                    </ul>
                                </li>

                                <li><strong>Inter-Service Communication:</strong>
                                    <ul>
                                        <li><strong>Synchronous REST:</strong> HTTP-based, easy, widely supported, but
                                            slower</li>
                                        <li><strong>Synchronous gRPC:</strong> Binary protocol, fast, type-safe, but
                                            less human-readable</li>
                                        <li><strong>Async Message Queue:</strong> Point-to-point, one consumer, for task
                                            distribution</li>
                                        <li><strong>Async Pub/Sub:</strong> One message to multiple subscribers, for
                                            event notifications</li>
                                    </ul>
                                </li>

                                <li><strong>Service Discovery:</strong>
                                    <ul>
                                        <li>Problem: Services need to find each other (IPs change)</li>
                                        <li><strong>Client-Side:</strong> Service registers, client queries registry,
                                            client load balances</li>
                                        <li><strong>Server-Side:</strong> Client requests via load balancer, LB queries
                                            registry</li>
                                        <li><strong>DNS-Based:</strong> Each service has DNS name, simple but limited
                                        </li>
                                    </ul>
                                </li>

                                <li><strong>API Gateway Pattern:</strong>
                                    <ul>
                                        <li>Single entry point for all clients</li>
                                        <li>Responsibilities: Authentication, rate limiting, request transformation,
                                            aggregation, caching, monitoring</li>
                                    </ul>
                                </li>

                                <li><strong>Back-of-Envelope Calculations (CRITICAL FOR INTERVIEWS):</strong>
                                    <ul>
                                        <li><strong>Key Numbers:</strong> 1KB=1,000 bytes, 1MB=1,000KB, 1GB=1,000MB,
                                            1TB=1,000GB, 1PB=1,000TB</li>
                                        <li><strong>Time:</strong> 1 second=1,000ms, 1ms=1,000μs</li>
                                        <li><strong>Latency:</strong> Memory=100ns, SSD=150μs, Disk=10ms,
                                            Network=10μs-150ms</li>
                                        <li><strong>Formula - QPS:</strong> (DAU × Actions/User) / 86,400</li>
                                        <li><strong>Formula - Storage:</strong> Num_Items × Size_Per_Item</li>
                                        <li><strong>Formula - Bandwidth:</strong> QPS × Avg_Size × 8 / 1,000,000 (for
                                            Mbps)</li>
                                        <li><strong>Formula - Servers:</strong> Peak_QPS / QPS_Per_Server</li>
                                        <li><strong>Formula - Cache:</strong> Total_Data × Hot_Data_Percentage (80-20
                                            rule)</li>
                                    </ul>
                                </li>

                                <li><strong>Standard Assumptions for Interviews:</strong>
                                    <ul>
                                        <li>Single server handles: 1,000-10,000 QPS</li>
                                        <li>Database handles: 1,000-5,000 QPS</li>
                                        <li>Cache (Redis) handles: 100,000-500,000 QPS</li>
                                        <li>Peak traffic: 2-3x average</li>
                                        <li>80-20 rule: 20% data gets 80% traffic</li>
                                        <li>1 char = 1 byte, Image = 200KB-1MB, Video (1min) = 5-10MB</li>
                                    </ul>
                                </li>
                            </ul>

                            <h5>💻 Practice Tasks:</h5>
                            <ul class="practice-list">
                                <li>Design microservices for e-commerce: Break into User, Catalog, Cart, Order, Payment,
                                    Inventory, Shipping, Notification services</li>
                                <li>Design communication patterns: Which should be sync vs async?</li>
                                <li>Calculate Twitter scale: 500M DAU, 2 tweets/day, 100 views/day</li>
                                <li>Calculate: Write QPS, Read QPS, Storage (5 years), Bandwidth, Cache size, Servers
                                    needed</li>
                                <li>Calculate WhatsApp storage: 2B users, 50 messages/day, 100 bytes text, 10% media
                                    (500KB), 5 years</li>
                                <li>Calculate Instagram shards: 1B users, 0.5 photos/day, 1KB metadata, max 1TB per
                                    shard</li>
                                <li>Calculate Netflix bandwidth: 100M concurrent viewers, 5 Mbps per stream</li>
                            </ul>

                            <h5>📖 Key Questions to Answer:</h5>
                            <ul class="resources-list">
                                <li>When should you use microservices vs monolith?</li>
                                <li>How do you define service boundaries?</li>
                                <li>Synchronous (REST) vs Asynchronous (events) - when each?</li>
                                <li>How to handle distributed transactions in microservices?</li>
                                <li>How many servers for 100K QPS?</li>
                                <li>How much storage for 1B users, 5 years?</li>
                                <li>What's 80-20 rule and why important?</li>
                                <li>How to estimate cache size?</li>
                            </ul>
                        </div>
                    </div>

                    <!-- Day 19 -->
                    <div class="day-guide-card">
                        <div class="day-guide-header">
                            <span class="day-number-badge">Day 19</span>
                            <h4>Event-Driven Architecture</h4>
                        </div>

                        <div class="concepts-section">
                            <h5>🎯 Core Concepts to Learn:</h5>
                            <ul class="concepts-list">
                                <li><strong>Event-Driven Architecture (EDA):</strong>
                                    <ul>
                                        <li>Definition: Systems communicate through events</li>
                                        <li>Event: Significant change in state (UserRegistered, OrderPlaced,
                                            PaymentProcessed)</li>
                                        <li>Components: Event Producer, Event Channel (broker), Event Consumer</li>
                                        <li><strong>Benefits:</strong> Loose coupling, scalability, flexibility,
                                            real-time, resilience</li>
                                        <li><strong>Challenges:</strong> Complexity, debugging, eventual consistency,
                                            duplicates, ordering</li>
                                    </ul>
                                </li>

                                <li><strong>Event Sourcing:</strong>
                                    <ul>
                                        <li>Core idea: Store all changes as sequence of events, not current state</li>
                                        <li>Example: Bank account - store deposits/withdrawals, not just balance</li>
                                        <li>Current state: Derived by replaying events</li>
                                        <li><strong>Benefits:</strong> Audit trail, time travel, debugging, event
                                            replay, multiple views</li>
                                        <li><strong>Challenges:</strong> Storage (events grow), complexity, schema
                                            changes, performance</li>
                                        <li>Snapshots: Save state periodically to avoid replaying millions of events
                                        </li>
                                    </ul>
                                </li>

                                <li><strong>CQRS (Command Query Responsibility Segregation):</strong>
                                    <ul>
                                        <li>Core idea: Separate write model from read model</li>
                                        <li><strong>Write Side:</strong> Optimized for writes, normalized, enforce
                                            business rules, emit events</li>
                                        <li><strong>Read Side:</strong> Optimized for reads, denormalized views, fast
                                            queries, built from events</li>
                                        <li>Can have multiple read models for different use cases</li>
                                        <li><strong>Benefits:</strong> Scalable reads, optimized queries, independent
                                            scaling</li>
                                        <li><strong>Challenges:</strong> Complexity, eventual consistency,
                                            synchronization</li>
                                        <li>Perfect with Event Sourcing: Events update read models</li>
                                    </ul>
                                </li>

                                <li><strong>Apache Kafka:</strong>
                                    <ul>
                                        <li>Distributed event streaming platform</li>
                                        <li><strong>Topic:</strong> Category of events (orders, payments, user-activity)
                                        </li>
                                        <li><strong>Partition:</strong> Shard of topic for parallelism (ordered within
                                            partition)</li>
                                        <li><strong>Producer:</strong> Publishes events to topics</li>
                                        <li><strong>Consumer:</strong> Subscribes and processes events</li>
                                        <li><strong>Consumer Group:</strong> Multiple consumers working together (each
                                            partition → one consumer)</li>
                                        <li><strong>Offset:</strong> Position in partition (can replay by resetting)
                                        </li>
                                        <li><strong>Guarantees:</strong> Ordering within partition, durability,
                                            at-least-once delivery</li>
                                    </ul>
                                </li>

                                <li><strong>Kafka vs Traditional Message Queue:</strong>
                                    <ul>
                                        <li><strong>Kafka:</strong> Long-term persistence, very high throughput, message
                                            replay possible</li>
                                        <li><strong>RabbitMQ:</strong> Short-term persistence, high throughput, consumed
                                            = gone</li>
                                        <li>Use Kafka for: Event streaming, logs, metrics, event sourcing</li>
                                        <li>Use RabbitMQ for: Task queues, RPC</li>
                                    </ul>
                                </li>

                                <li><strong>Saga Patterns (Event-Based):</strong>
                                    <ul>
                                        <li><strong>Choreography:</strong> Each service reacts to events, no central
                                            coordinator</li>
                                        <li>Example: OrderPlaced → InventoryReserved → PaymentCompleted → OrderShipped
                                        </li>
                                        <li><strong>Orchestration:</strong> Central orchestrator commands each service
                                        </li>
                                        <li>Discussed in detail on Day 16</li>
                                    </ul>
                                </li>
                            </ul>

                            <h5>💻 Practice Tasks:</h5>
                            <ul class="practice-list">
                                <li>Design Event Sourcing for shopping cart: CartCreated, ItemAdded, ItemRemoved,
                                    CartCheckedOut</li>
                                <li>Implement snapshot functionality (save state every 10 events)</li>
                                <li>Add time-travel queries ("What was cart state at 2 PM?")</li>
                                <li>Design CQRS for blog platform: Write model (commands) and multiple read models (post
                                    list, post detail, author posts)</li>
                                <li>Design event handlers to update read models from events</li>
                                <li>Build event-driven order system with Kafka: Order Service, Inventory Service,
                                    Payment Service, Shipping Service</li>
                                <li>Implement compensation for failures</li>
                                <li>Design analytics pipeline: Collect user events, multiple consumers (analytics,
                                    recommendations, fraud)</li>
                            </ul>

                            <h5>📖 Key Questions to Answer:</h5>
                            <ul class="resources-list">
                                <li>What's difference between Event Sourcing and Change Data Capture?</li>
                                <li>When should you use CQRS without Event Sourcing?</li>
                                <li>How do you handle schema evolution in Event Sourcing?</li>
                                <li>Kafka vs RabbitMQ - when to use each?</li>
                                <li>How do you ensure ordering in Kafka?</li>
                                <li>What are downsides of event-driven architecture?</li>
                                <li>How do you handle duplicate events (idempotency)?</li>
                                <li>How do you debug event-driven systems?</li>
                            </ul>
                        </div>
                    </div>

                    <!-- Day 20 -->
                    <div class="day-guide-card">
                        <div class="day-guide-header">
                            <span class="day-number-badge">Day 20</span>
                            <h4>Observability & Monitoring</h4>
                        </div>

                        <div class="concepts-section">
                            <h5>🎯 Core Concepts to Learn:</h5>
                            <ul class="concepts-list">
                                <li><strong>Observability vs Monitoring:</strong>
                                    <ul>
                                        <li><strong>Monitoring:</strong> Predefined metrics, known failures, alert on
                                            thresholds</li>
                                        <li><strong>Observability:</strong> Understand system from outputs, discover
                                            unknowns, answer arbitrary questions</li>
                                    </ul>
                                </li>

                                <li><strong>Three Pillars of Observability:</strong>
                                    <ul>
                                        <li><strong>1. Metrics (Aggregated Numbers):</strong>
                                            <ul>
                                                <li>Examples: Request rate (req/sec), Error rate, Latency (p50, p95,
                                                    p99), CPU/Memory usage</li>
                                                <li>Types: Counter (only increases), Gauge (up/down), Histogram
                                                    (distribution)</li>
                                                <li>Storage: Time-series databases (Prometheus, InfluxDB)</li>
                                            </ul>
                                        </li>
                                        <li><strong>2. Logs (Discrete Events):</strong>
                                            <ul>
                                                <li>Text records of events with timestamp</li>
                                                <li>Levels: DEBUG, INFO, WARN, ERROR, FATAL</li>
                                                <li>Structured logs: JSON format with fields (better than plain text)
                                                </li>
                                                <li>Storage: Elasticsearch, Splunk, Loki</li>
                                            </ul>
                                        </li>
                                        <li><strong>3. Traces (Request Journey):</strong>
                                            <ul>
                                                <li>Follow single request across services</li>
                                                <li>Span: Single operation (API call, DB query)</li>
                                                <li>Trace: Collection of spans for one request</li>
                                                <li>Shows where time is spent in distributed system</li>
                                                <li>Tools: Jaeger, Zipkin, AWS X-Ray</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>

                                <li><strong>Distributed Tracing:</strong>
                                    <ul>
                                        <li>Generate Trace ID: First service creates unique ID, passes to all downstream
                                        </li>
                                        <li>Generate Span ID: Each operation gets span ID with parent-child relationship
                                        </li>
                                        <li>Record Timing: Start time, end time, duration</li>
                                        <li>Add Context: Service name, operation, tags (user_id, order_id), logs</li>
                                        <li>Propagation: HTTP headers (traceparent, tracestate)</li>
                                    </ul>
                                </li>

                                <li><strong>SLI / SLO / SLA:</strong>
                                    <ul>
                                        <li><strong>SLI (Service Level Indicator):</strong> Metric that measures service
                                            health
                                            <ul>
                                                <li>Examples: Request latency (p99 < 200ms), Error rate (< 0.1%),
                                                        Availability (uptime %)</li>
                                            </ul>
                                        </li>
                                        <li><strong>SLO (Service Level Objective):</strong> Target value for SLI
                                            <ul>
                                                <li>Examples: "99.9% uptime", "p99 latency < 200ms", "Error rate < 0.1%"
                                                        </li>
                                                <li>Error Budget: Allowed downtime before breaking SLO (0.1% = 43
                                                    min/month for 99.9% SLO)</li>
                                            </ul>
                                        </li>
                                        <li><strong>SLA (Service Level Agreement):</strong> Contract with consequences
                                            <ul>
                                                <li>Examples: "99.9% uptime, or refund 10%"</li>
                                                <li>Relationship: SLA ≤ SLO < SLI (measurement)</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>

                                <li><strong>Alerting Best Practices:</strong>
                                    <ul>
                                        <li><strong>Symptom-Based:</strong> Alert on user impact (high error rate, slow
                                            response)</li>
                                        <li><strong>Reduce Noise:</strong> Use thresholds and time windows (not single
                                            spike)</li>
                                        <li><strong>Severity Levels:</strong> P1 (page on-call), P2 (notify business
                                            hours), P3 (track), P4 (nice to fix)</li>
                                        <li><strong>Actionable:</strong> Include runbook link, clear next steps</li>
                                        <li><strong>Golden Signals:</strong> Latency, Traffic, Errors, Saturation</li>
                                    </ul>
                                </li>

                                <li><strong>Logging Best Practices:</strong>
                                    <ul>
                                        <li>Use structured logging (JSON with fields)</li>
                                        <li>Always log: Request ID, user ID, errors with stack traces</li>
                                        <li>Never log: Passwords, credit cards, PII</li>
                                        <li>Log sampling: Sample high-volume logs (1%), always log errors (100%)</li>
                                        <li>Centralized logging: Collect from all servers (ELK stack, Splunk)</li>
                                    </ul>
                                </li>

                                <li><strong>Monitoring Stack Example:</strong>
                                    <ul>
                                        <li><strong>Metrics:</strong> Prometheus (scrapes metrics) → Grafana
                                            (visualizations)</li>
                                        <li><strong>Logs:</strong> Application → Filebeat → Logstash → Elasticsearch →
                                            Kibana</li>
                                        <li><strong>Traces:</strong> Application (instrumented) → Jaeger Agent →
                                            Collector → Query UI</li>
                                    </ul>
                                </li>
                            </ul>

                            <h5>💻 Practice Tasks:</h5>
                            <ul class="practice-list">
                                <li>Implement distributed tracing: Instrument API gateway, order service, payment
                                    service with spans</li>
                                <li>Run Jaeger locally and generate traces for different scenarios</li>
                                <li>Analyze slow requests to identify bottleneck service</li>
                                <li>Set up Prometheus monitoring: Track request count, latency histogram, active users
                                    gauge</li>
                                <li>Create Grafana dashboard: Request rate, error rate, p99 latency, active users</li>
                                <li>Set up alerts: Error rate > 1%, p99 latency > 200ms</li>
                                <li>Design SLOs for e-commerce API: Define SLIs, set SLOs with buffer, calculate error
                                    budget</li>
                                <li>Create error budget policy: What to do at different budget levels</li>
                                <li>Implement structured logging with correlation ID across all services</li>
                                <li>Design monitoring for microservices: Golden signals per service, overview dashboard,
                                    alerts with runbooks</li>
                            </ul>

                            <h5>📖 Key Questions to Answer:</h5>
                            <ul class="resources-list">
                                <li>What's difference between monitoring and observability?</li>
                                <li>Why use distributed tracing instead of just logs?</li>
                                <li>How do you set SLOs? (Based on user experience)</li>
                                <li>What's an error budget and why useful?</li>
                                <li>What are four golden signals?</li>
                                <li>How to prevent alert fatigue?</li>
                                <li>When to page on-call vs send notification?</li>
                                <li>How to monitor microservices effectively?</li>
                            </ul>
                        </div>
                    </div>

                    <!-- Day 21 -->
                    <div class="day-guide-card">
                        <div class="day-guide-header">
                            <span class="day-number-badge">Day 21</span>
                            <h4>Week 3 Review & Advanced Project</h4>
                        </div>

                        <div class="concepts-section">
                            <h5>🎯 Week 3 Review Checklist:</h5>
                            <ul class="concepts-list">
                                <li><strong>Distributed Systems (Days 15-17):</strong>
                                    <ul>
                                        <li>Can explain CAP theorem with real examples?</li>
                                        <li>Understand trade-offs (consistency vs availability, latency vs throughput)?
                                        </li>
                                        <li>Know different consistency models (strong, eventual, causal)?</li>
                                        <li>Can explain 2PC vs Saga?</li>
                                        <li>Understand Saga orchestration vs choreography?</li>
                                        <li>Can explain Raft leader election?</li>
                                        <li>Understand quorum reads/writes?</li>
                                        <li>Know how to prevent split-brain?</li>
                                    </ul>
                                </li>

                                <li><strong>Microservices (Day 18):</strong>
                                    <ul>
                                        <li>Can explain microservices benefits and challenges?</li>
                                        <li>Know how to define service boundaries?</li>
                                        <li>Understand inter-service communication (sync vs async)?</li>
                                        <li>Can do back-of-envelope calculations?</li>
                                        <li>Know key formulas (QPS, storage, bandwidth, servers)?</li>
                                        <li>Can estimate capacity for given requirements?</li>
                                    </ul>
                                </li>

                                <li><strong>Event-Driven Architecture (Day 19):</strong>
                                    <ul>
                                        <li>Understand event sourcing pattern?</li>
                                        <li>Can explain CQRS and when to use?</li>
                                        <li>Know Kafka concepts (topics, partitions, consumer groups)?</li>
                                        <li>Understand event-driven vs request-response?</li>
                                    </ul>
                                </li>

                                <li><strong>Observability (Day 20):</strong>
                                    <ul>
                                        <li>Know three pillars (metrics, logs, traces)?</li>
                                        <li>Can explain distributed tracing?</li>
                                        <li>Understand SLI / SLO / SLA?</li>
                                        <li>Know golden signals?</li>
                                        <li>Can design alerting strategy?</li>
                                    </ul>
                                </li>
                            </ul>

                            <h5>💻 Advanced Project: Distributed Chat System</h5>
                            <ul class="practice-list">
                                <li><strong>Requirements:</strong>
                                    <ul>
                                        <li>Support 100M users, 50M daily active</li>
                                        <li>Real-time messaging (< 100ms latency)</li>
                                        <li>Message persistence (5 years)</li>
                                        <li>Group chats (up to 1000 members)</li>
                                        <li>Read receipts, online/offline status</li>
                                        <li>Message search, multiple devices per user</li>
                                    </ul>
                                </li>

                                <li><strong>Part 1: Capacity Estimation</strong>
                                    <ul>
                                        <li>Calculate Write QPS: 50M users × 50 messages/day = ?</li>
                                        <li>Calculate Read QPS: 50M users × 100 receives/day = ?</li>
                                        <li>Calculate Storage: Text messages + media (10%), 5 years = ?</li>
                                        <li>Calculate WebSocket connections: Concurrent users = ?</li>
                                        <li>Calculate Servers needed: Based on connections per server</li>
                                        <li>Calculate Bandwidth: Upload and download requirements</li>
                                        <li>Calculate Database shards: Based on QPS and storage</li>
                                    </ul>
                                </li>

                                <li><strong>Part 2: High-Level Design</strong>
                                    <ul>
                                        <li>Components: WebSocket servers, API Gateway, Chat Service, User Service,
                                            Presence Service, Media Service, Search Service</li>
                                        <li>Databases: User DB (sharded), Message DB (sharded), Presence Cache (Redis),
                                            Object Storage (S3)</li>
                                        <li>Use consistent hashing for user → WebSocket server mapping</li>
                                    </ul>
                                </li>

                                <li><strong>Part 3: Detailed Design</strong>
                                    <ul>
                                        <li>Real-time messaging flow: User A → WebSocket → Chat Service → Message DB →
                                            Find User B's server → Push to User B</li>
                                        <li>Group chat: Fan-out on read (not write) for large groups</li>
                                        <li>Online/offline presence: Redis with TTL, heartbeat every 30 seconds</li>
                                        <li>Message search: Elasticsearch index with conversation_id filter</li>
                                        <li>Read receipts: Update message status, notify sender via WebSocket</li>
                                        <li>Typing indicators: Ephemeral events, don't persist</li>
                                        <li>End-to-end encryption: Encrypt with recipient's public key</li>
                                    </ul>
                                </li>

                                <li><strong>Part 4: Trade-off Analysis</strong>
                                    <ul>
                                        <li>WebSocket vs Polling: Choose WebSocket (real-time requirements)</li>
                                        <li>Fan-out on write vs read: Choose read for large groups (1000 members)</li>
                                        <li>Strong vs eventual consistency: Eventual for messages (availability >
                                            consistency)</li>
                                        <li>Sharding strategy: Shard by conversation_id (all messages together)</li>
                                    </ul>
                                </li>
                            </ul>

                            <h5>📖 Week 3 Summary:</h5>
                            <ul class="resources-list">
                                <li>Distributed systems require trade-offs (CAP theorem)</li>
                                <li>Microservices add complexity but enable scalability</li>
                                <li>Event-driven architecture enables loose coupling</li>
                                <li>Observability critical for debugging distributed systems</li>
                                <li>Always do capacity calculations in interviews</li>
                                <li>Practice explaining trade-offs and justify decisions</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <!-- Weeks 4-12: Modern Architecture & System Design Mastery (Days 22-90) -->
                <!-- Add this to your existing study guide HTML after Week 3 -->

                <div class="study-guide-week">
                    <h3 class="week-header-guide">Week 4: Modern Architecture Patterns (Days 22-28)</h3>

                    <!-- Day 22 -->
                    <div class="day-guide-card">
                        <div class="day-guide-header">
                            <span class="day-number-badge">Day 22</span>
                            <h4>Cloud-Native Architecture</h4>
                        </div>

                        <div class="concepts-section">
                            <h5>🎯 Core Concepts to Learn:</h5>
                            <ul class="concepts-list">
                                <li><strong>12-Factor App Methodology:</strong>
                                    <ul>
                                        <li><strong>I. Codebase:</strong> One codebase tracked in version control, many
                                            deploys</li>
                                        <li><strong>II. Dependencies:</strong> Explicitly declare and isolate
                                            dependencies</li>
                                        <li><strong>III. Config:</strong> Store config in environment (never in code)
                                        </li>
                                        <li><strong>IV. Backing services:</strong> Treat backing services as attached
                                            resources</li>
                                        <li><strong>V. Build, release, run:</strong> Strictly separate build and run
                                            stages</li>
                                        <li><strong>VI. Processes:</strong> Execute app as stateless processes</li>
                                        <li><strong>VII. Port binding:</strong> Export services via port binding</li>
                                        <li><strong>VIII. Concurrency:</strong> Scale out via the process model</li>
                                        <li><strong>IX. Disposability:</strong> Maximize robustness with fast startup
                                            and graceful shutdown</li>
                                        <li><strong>X. Dev/prod parity:</strong> Keep development, staging, and
                                            production as similar as possible</li>
                                        <li><strong>XI. Logs:</strong> Treat logs as event streams</li>
                                        <li><strong>XII. Admin processes:</strong> Run admin/management tasks as one-off
                                            processes</li>
                                    </ul>
                                </li>

                                <li><strong>Container Orchestration with Kubernetes:</strong>
                                    <ul>
                                        <li><strong>Pods:</strong> Smallest deployable units (one or more containers)
                                        </li>
                                        <li><strong>Deployments:</strong> Declarative updates for pods and replica sets
                                        </li>
                                        <li><strong>Services:</strong> Stable network endpoint for accessing pods</li>
                                        <li><strong>ConfigMaps & Secrets:</strong> Configuration management</li>
                                        <li><strong>Ingress:</strong> External access to services (HTTP/HTTPS routing)
                                        </li>
                                        <li><strong>Horizontal Pod Autoscaler:</strong> Auto-scaling based on
                                            CPU/memory/custom metrics</li>
                                        <li><strong>Namespaces:</strong> Virtual clusters for resource isolation</li>
                                        <li><strong>StatefulSets:</strong> For stateful applications (databases, queues)
                                        </li>
                                        <li><strong>DaemonSets:</strong> Run pod on every node (logging, monitoring
                                            agents)</li>
                                    </ul>
                                </li>

                                <li><strong>Service Mesh Concepts:</strong>
                                    <ul>
                                        <li>Dedicated infrastructure layer for service-to-service communication</li>
                                        <li><strong>Sidecar Pattern:</strong> Proxy container alongside each service
                                        </li>
                                        <li><strong>Features:</strong> Load balancing, service discovery, failure
                                            recovery, metrics, tracing</li>
                                        <li><strong>Traffic Management:</strong> Canary deployments, A/B testing,
                                            traffic splitting</li>
                                        <li><strong>Security:</strong> mTLS between services, authentication,
                                            authorization</li>
                                        <li><strong>Examples:</strong> Istio, Linkerd, Consul Connect</li>
                                        <li><strong>When to use:</strong> Many microservices (>10), complex traffic
                                            routing needs</li>
                                    </ul>
                                </li>

                                <li><strong>Serverless Architecture:</strong>
                                    <ul>
                                        <li><strong>Function as a Service (FaaS):</strong> AWS Lambda, Azure Functions,
                                            Google Cloud Functions</li>
                                        <li><strong>Event-driven execution:</strong> Functions triggered by events</li>
                                        <li><strong>Benefits:</strong> No server management, automatic scaling,
                                            pay-per-use</li>
                                        <li><strong>Limitations:</strong> Cold starts (latency), execution time limits,
                                            stateless</li>
                                        <li><strong>Use cases:</strong> API backends, data processing, scheduled tasks,
                                            webhooks</li>
                                        <li><strong>Serverless vs Containers:</strong> When to use each</li>
                                    </ul>
                                </li>
                            </ul>

                            <h5>💻 Practice Tasks:</h5>
                            <ul class="practice-list">
                                <li>Deploy application on Kubernetes cluster (pods, services, deployments)</li>
                                <li>Configure service mesh (Istio) for microservices communication</li>
                                <li>Build serverless function triggered by S3 upload event</li>
                                <li>Design cloud-native e-commerce platform using K8s and serverless</li>
                                <li>Compare deployment strategies: Blue-green, canary, rolling updates</li>
                                <li>Design auto-scaling strategy based on custom metrics</li>
                            </ul>

                            <h5>📖 Key Questions:</h5>
                            <ul class="resources-list">
                                <li>What are the 12 factors and why important for cloud-native apps?</li>
                                <li>When would you use Kubernetes vs serverless?</li>
                                <li>What problems does service mesh solve?</li>
                                <li>How does sidecar pattern work in service mesh?</li>
                                <li>What are trade-offs of serverless (cost, cold starts, limits)?</li>
                                <li>How to handle stateful applications in Kubernetes?</li>
                            </ul>
                        </div>
                    </div>

                    <!-- Day 23 -->
                    <div class="day-guide-card">
                        <div class="day-guide-header">
                            <span class="day-number-badge">Day 23</span>
                            <h4>API Design & Management</h4>
                        </div>

                        <div class="concepts-section">
                            <h5>🎯 Core Concepts to Learn:</h5>
                            <ul class="concepts-list">
                                <li><strong>RESTful API Design Principles:</strong>
                                    <ul>
                                        <li><strong>Resources:</strong> Everything is a resource (noun-based URLs)</li>
                                        <li><strong>HTTP Methods:</strong> GET (read), POST (create), PUT (update),
                                            PATCH (partial), DELETE</li>
                                        <li><strong>Statelessness:</strong> Each request is independent</li>
                                        <li><strong>URL Structure:</strong> /users, /users/123, /users/123/orders</li>
                                        <li><strong>Status Codes:</strong> 2xx (success), 3xx (redirect), 4xx (client
                                            error), 5xx (server error)</li>
                                        <li><strong>Idempotency:</strong> GET, PUT, DELETE are idempotent; POST is not
                                        </li>
                                        <li><strong>Versioning:</strong> /v1/users or header-based versioning</li>
                                    </ul>
                                </li>

                                <li><strong>GraphQL vs REST:</strong>
                                    <ul>
                                        <li><strong>GraphQL Benefits:</strong> Single endpoint, fetch exactly what
                                            needed, strongly typed, no over/under-fetching</li>
                                        <li><strong>GraphQL Challenges:</strong> Caching harder, complex queries,
                                            learning curve</li>
                                        <li><strong>REST Benefits:</strong> Simple, cacheable, well understood,
                                            stateless</li>
                                        <li><strong>REST Challenges:</strong> Over/under-fetching, multiple requests,
                                            versioning</li>
                                        <li><strong>When GraphQL:</strong> Complex data requirements, mobile apps</li>
                                        <li><strong>When REST:</strong> Simple CRUD, need caching, standard operations
                                        </li>
                                    </ul>
                                </li>

                                <li><strong>API Versioning Strategies:</strong>
                                    <ul>
                                        <li><strong>URL versioning:</strong> /v1/users, /v2/users (most common)</li>
                                        <li><strong>Header versioning:</strong> Accept: application/vnd.myapi.v2+json
                                        </li>
                                        <li><strong>Query parameter:</strong> /users?version=2</li>
                                        <li><strong>When to version:</strong> Breaking changes, backwards incompatible
                                        </li>
                                        <li><strong>Semantic versioning:</strong> Major.Minor.Patch</li>
                                    </ul>
                                </li>
                            </ul>

                            <h5>💻 Practice Tasks:</h5>
                            <ul class="practice-list">
                                <li>Design RESTful API for social platform (users, posts, comments, likes)</li>
                                <li>Design GraphQL schema for same platform</li>
                                <li>Compare REST vs GraphQL for different features</li>
                                <li>Design API versioning strategy for mobile banking app</li>
                                <li>Design API for backward compatibility</li>
                            </ul>

                            <h5>📖 Key Questions:</h5>
                            <ul class="resources-list">
                                <li>What makes API RESTful?</li>
                                <li>GraphQL vs REST - when to use each?</li>
                                <li>How to version APIs without breaking clients?</li>
                                <li>How to design API for mobile apps (minimize requests)?</li>
                                <li>How to handle API deprecation?</li>
                            </ul>
                        </div>
                    </div>

                    <!-- Continue with remaining days... -->
                    <!-- Due to length, showing structure for remaining days -->

                </div>

                <!-- Week 5: Classic System Design Problems -->
                <div class="study-guide-week">
                    <h3 class="week-header-guide">Week 5: Classic System Design Problems (Days 29-35)</h3>

                    <div class="day-guide-card">
                        <div class="day-guide-header">
                            <span class="day-number-badge">Day 29-30</span>
                            <h4>URL Shortener (Complete System)</h4>
                        </div>

                        <div class="concepts-section">
                            <h5>🎯 Core Concepts to Master:</h5>
                            <ul class="concepts-list">
                                <li><strong>URL Encoding Strategies</strong></li>
                                <li><strong>Database Schema Design</strong></li>
                                <li><strong>Caching Strategy</strong></li>
                                <li><strong>Analytics Implementation</strong></li>
                                <li><strong>Rate Limiting</strong></li>
                                <li><strong>High Availability Design</strong></li>
                            </ul>
                        </div>
                    </div>

                    <div class="day-guide-card">
                        <div class="day-guide-header">
                            <span class="day-number-badge">Day 32-33</span>
                            <h4>Twitter News Feed (Complete System)</h4>
                        </div>

                        <div class="concepts-section">
                            <h5>🎯 Core Concepts to Master:</h5>
                            <ul class="concepts-list">
                                <li><strong>Fan-out Approaches</strong></li>
                                <li><strong>Hybrid Approach for Celebrities</strong></li>
                                <li><strong>Feed Ranking Algorithms</strong></li>
                                <li><strong>Real-time Updates</strong></li>
                                <li><strong>Trending Topics</strong></li>
                            </ul>
                        </div>
                    </div>
                </div>

                <!-- Week 6: Advanced Applications -->
                <div class="study-guide-week">
                    <h3 class="week-header-guide">Week 6: Advanced Applications (Days 36-42)</h3>

                    <div class="day-guide-card">
                        <div class="day-guide-header">
                            <span class="day-number-badge">Day 36-37</span>
                            <h4>Video Streaming Platform (Netflix-like)</h4>
                        </div>

                        <div class="concepts-section">
                            <h5>🎯 Core Concepts to Master:</h5>
                            <ul class="concepts-list">
                                <li><strong>Video Encoding & Transcoding</strong></li>
                                <li><strong>CDN Strategy for Video</strong></li>
                                <li><strong>Adaptive Bitrate Streaming</strong></li>
                                <li><strong>Live Streaming Architecture</strong></li>
                                <li><strong>Content Moderation</strong></li>
                            </ul>
                        </div>
                    </div>

                    <div class="day-guide-card">
                        <div class="day-guide-header">
                            <span class="day-number-badge">Day 38-39</span>
                            <h4>Ride Sharing Platform (Uber-like)</h4>
                        </div>

                        <div class="concepts-section">
                            <h5>🎯 Core Concepts to Master:</h5>
                            <ul class="concepts-list">
                                <li><strong>Driver-Rider Matching</strong></li>
                                <li><strong>Real-time Location Tracking</strong></li>
                                <li><strong>ETA Calculation</strong></li>
                                <li><strong>Dynamic Pricing (Surge)</strong></li>
                                <li><strong>Route Optimization</strong></li>
                            </ul>
                        </div>
                    </div>

                    <div class="day-guide-card">
                        <div class="day-guide-header">
                            <span class="day-number-badge">Day 40-41</span>
                            <h4>Search Engine (Google-like)</h4>
                        </div>

                        <div class="concepts-section">
                            <h5>🎯 Core Concepts to Master:</h5>
                            <ul class="concepts-list">
                                <li><strong>Web Crawling Strategies</strong></li>
                                <li><strong>Distributed Indexing</strong></li>
                                <li><strong>PageRank Algorithm</strong></li>
                                <li><strong>Query Processing</strong></li>
                                <li><strong>Result Ranking</strong></li>
                            </ul>
                        </div>
                    </div>
                </div>

                <!-- Week 7-8: Specialized Systems -->
                <div class="study-guide-week">
                    <h3 class="week-header-guide">Weeks 7-8: Specialized Systems & Data Processing (Days 43-56)</h3>

                    <div class="day-guide-card">
                        <div class="day-guide-header">
                            <span class="day-number-badge">Day 43-44</span>
                            <h4>Messaging Systems (WhatsApp/Slack)</h4>
                        </div>

                        <div class="concepts-section">
                            <h5>🎯 Core Concepts to Master:</h5>
                            <ul class="concepts-list">
                                <li><strong>One-to-One Messaging</strong></li>
                                <li><strong>Group Chat Architecture</strong></li>
                                <li><strong>Message Delivery Guarantees</strong></li>
                                <li><strong>Read Receipts & Typing Indicators</strong></li>
                                <li><strong>End-to-End Encryption</strong></li>
                                <li><strong>Media Handling (Images, Videos)</strong></li>
                            </ul>

                            <h5>💻 Practice Tasks:</h5>
                            <ul class="practice-list">
                                <li>Design message delivery system with at-least-once guarantee</li>
                                <li>Design group chat for 10,000 members</li>
                                <li>Design presence system (online/offline/last seen)</li>
                                <li>Calculate: Storage for 1B users, 50 messages/day, 5 years</li>
                                <li>Design end-to-end encryption key exchange</li>
                            </ul>
                        </div>
                    </div>

                    <div class="day-guide-card">
                        <div class="day-guide-header">
                            <span class="day-number-badge">Day 45-46</span>
                            <h4>Social Network (Facebook-like)</h4>
                        </div>

                        <div class="concepts-section">
                            <h5>🎯 Core Concepts to Master:</h5>
                            <ul class="concepts-list">
                                <li><strong>Friend Relationships (Graph Database)</strong></li>
                                <li><strong>News Feed Generation</strong></li>
                                <li><strong>Photo/Video Storage</strong></li>
                                <li><strong>Friend Suggestions</strong></li>
                                <li><strong>Notification System</strong></li>
                            </ul>
                        </div>
                    </div>

                    <div class="day-guide-card">
                        <div class="day-guide-header">
                            <span class="day-number-badge">Day 47-48</span>
                            <h4>E-Commerce Platform (Amazon-like)</h4>
                        </div>

                        <div class="concepts-section">
                            <h5>🎯 Core Concepts to Master:</h5>
                            <ul class="concepts-list">
                                <li><strong>Product Catalog & Search</strong></li>
                                <li><strong>Shopping Cart</strong></li>
                                <li><strong>Order Processing Pipeline</strong></li>
                                <li><strong>Inventory Management</strong></li>
                                <li><strong>Payment Processing</strong></li>
                                <li><strong>Recommendation Engine</strong></li>
                            </ul>
                        </div>
                    </div>

                    <div class="day-guide-card">
                        <div class="day-guide-header">
                            <span class="day-number-badge">Day 49-50</span>
                            <h4>Data Processing Pipelines</h4>
                        </div>

                        <div class="concepts-section">
                            <h5>🎯 Core Concepts to Master:</h5>
                            <ul class="concepts-list">
                                <li><strong>Batch Processing (MapReduce, Spark)</strong></li>
                                <li><strong>Stream Processing (Kafka Streams, Flink)</strong></li>
                                <li><strong>ETL Pipelines</strong></li>
                                <li><strong>Data Warehousing</strong></li>
                                <li><strong>Lambda & Kappa Architectures</strong></li>
                            </ul>
                        </div>
                    </div>

                    <div class="day-guide-card">
                        <div class="day-guide-header">
                            <span class="day-number-badge">Day 51-52</span>
                            <h4>Notification System (Multi-Channel)</h4>
                        </div>

                        <div class="concepts-section">
                            <h5>🎯 Core Concepts to Master:</h5>
                            <ul class="concepts-list">
                                <li><strong>Push Notifications (Mobile)</strong></li>
                                <li><strong>Email Notifications</strong></li>
                                <li><strong>SMS Notifications</strong></li>
                                <li><strong>In-App Notifications</strong></li>
                                <li><strong>User Preferences & Opt-out</strong></li>
                                <li><strong>Rate Limiting Per Channel</strong></li>
                            </ul>
                        </div>
                    </div>

                    <div class="day-guide-card">
                        <div class="day-guide-header">
                            <span class="day-number-badge">Day 53-54</span>
                            <h4>Payment System (Stripe-like)</h4>
                        </div>

                        <div class="concepts-section">
                            <h5>🎯 Core Concepts to Master:</h5>
                            <ul class="concepts-list">
                                <li><strong>Payment Gateway Integration</strong></li>
                                <li><strong>Idempotency for Payments</strong></li>
                                <li><strong>Retry Logic & Failure Handling</strong></li>
                                <li><strong>Reconciliation</strong></li>
                                <li><strong>Fraud Detection</strong></li>
                                <li><strong>PCI Compliance</strong></li>
                            </ul>
                        </div>
                    </div>

                    <div class="day-guide-card">
                        <div class="day-guide-header">
                            <span class="day-number-badge">Day 55-56</span>
                            <h4>Gaming Backend & IoT Platform</h4>
                        </div>

                        <div class="concepts-section">
                            <h5>🎯 Gaming Backend Concepts:</h5>
                            <ul class="concepts-list">
                                <li><strong>Real-time Multiplayer (WebSocket)</strong></li>
                                <li><strong>Matchmaking Algorithms</strong></li>
                                <li><strong>Leaderboards</strong></li>
                                <li><strong>Game State Synchronization</strong></li>
                                <li><strong>Cheat Detection</strong></li>
                            </ul>

                            <h5>🎯 IoT Platform Concepts:</h5>
                            <ul class="concepts-list">
                                <li><strong>Device Management</strong></li>
                                <li><strong>Telemetry Data Ingestion</strong></li>
                                <li><strong>Time-Series Databases</strong></li>
                                <li><strong>Device Shadow (Last Known State)</strong></li>
                                <li><strong>OTA Updates</strong></li>
                            </ul>
                        </div>
                    </div>
                </div>

                <!-- Weeks 9-12: Interview Mastery -->
                <div class="study-guide-week">
                    <h3 class="week-header-guide">Weeks 9-12: Interview Mastery & Mock Interviews (Days 57-90)</h3>

                    <div class="day-guide-card">
                        <div class="day-guide-header">
                            <span class="day-number-badge">Days 57-63</span>
                            <h4>Week 9: Interview Framework & Communication</h4>
                        </div>

                        <div class="concepts-section">
                            <h5>🎯 Master Interview Framework:</h5>
                            <ul class="concepts-list">
                                <li><strong>Step 1: Clarify Requirements (5 min)</strong>
                                    <ul>
                                        <li>Functional requirements: What features?</li>
                                        <li>Non-functional: Scale, performance, availability?</li>
                                        <li>Out of scope: What NOT to design?</li>
                                    </ul>
                                </li>
                                <li><strong>Step 2: Capacity Estimation (5 min)</strong>
                                    <ul>
                                        <li>QPS calculations (read/write)</li>
                                        <li>Storage estimation</li>
                                        <li>Bandwidth requirements</li>
                                    </ul>
                                </li>
                                <li><strong>Step 3: API Design (5 min)</strong>
                                    <ul>
                                        <li>Core endpoints</li>
                                        <li>Request/response formats</li>
                                    </ul>
                                </li>
                                <li><strong>Step 4: High-Level Design (10 min)</strong>
                                    <ul>
                                        <li>Draw major components</li>
                                        <li>Data flow</li>
                                        <li>Technology choices</li>
                                    </ul>
                                </li>
                                <li><strong>Step 5: Deep Dive (15 min)</strong>
                                    <ul>
                                        <li>Pick 2-3 critical components</li>
                                        <li>Discuss algorithms, data structures</li>
                                        <li>Scaling strategies</li>
                                    </ul>
                                </li>
                                <li><strong>Step 6: Trade-offs (5 min)</strong>
                                    <ul>
                                        <li>Justify decisions</li>
                                        <li>Discuss alternatives</li>
                                        <li>Bottlenecks & solutions</li>
                                    </ul>
                                </li>
                            </ul>

                            <h5>💻 Communication Best Practices:</h5>
                            <ul class="practice-list">
                                <li><strong>Think out loud:</strong> Share reasoning process</li>
                                <li><strong>Ask clarifying questions:</strong> Don't make assumptions</li>
                                <li><strong>Draw diagrams:</strong> Visual communication</li>
                                <li><strong>Discuss trade-offs:</strong> Show depth of understanding</li>
                                <li><strong>Time management:</strong> Don't spend 30 min on one component</li>
                                <li><strong>Be receptive:</strong> Listen to hints from interviewer</li>
                            </ul>
                        </div>
                    </div>

                    <div class="day-guide-card">
                        <div class="day-guide-header">
                            <span class="day-number-badge">Days 64-70</span>
                            <h4>Week 10: Practice Common Questions</h4>
                        </div>

                        <div class="concepts-section">
                            <h5>🎯 Practice These Problems (45 min each):</h5>
                            <ul class="concepts-list">
                                <li><strong>Day 64:</strong> Design YouTube</li>
                                <li><strong>Day 65:</strong> Design Uber</li>
                                <li><strong>Day 66:</strong> Design WhatsApp</li>
                                <li><strong>Day 67:</strong> Design Netflix</li>
                                <li><strong>Day 68:</strong> Design Google Drive</li>
                                <li><strong>Day 69:</strong> Design Yelp</li>
                                <li><strong>Day 70:</strong> Design Ticketmaster</li>
                            </ul>

                            <h5>💻 For Each Problem:</h5>
                            <ul class="practice-list">
                                <li>Set 45-minute timer</li>
                                <li>Follow interview framework</li>
                                <li>Record yourself or practice with peer</li>
                                <li>Review and identify weak areas</li>
                            </ul>
                        </div>
                    </div>

                    <div class="day-guide-card">
                        <div class="day-guide-header">
                            <span class="day-number-badge">Days 71-77</span>
                            <h4>Week 11: Mock Interviews & Review</h4>
                        </div>

                        <div class="concepts-section">
                            <h5>🎯 Mock Interview Schedule:</h5>
                            <ul class="concepts-list">
                                <li><strong>Day 71-72:</strong> Mock Interview 1 - Design Twitter
                                    <ul>
                                        <li>Find interview partner (Pramp, interviewing.io)</li>
                                        <li>Record session</li>
                                        <li>Get feedback</li>
                                    </ul>
                                </li>
                                <li><strong>Day 73-74:</strong> Mock Interview 2 - Design Instagram</li>
                                <li><strong>Day 75-76:</strong> Mock Interview 3 - Design Uber</li>
                                <li><strong>Day 77:</strong> Review all mock interviews, identify patterns</li>
                            </ul>

                            <h5>💻 After Each Mock Interview:</h5>
                            <ul class="practice-list">
                                <li>What went well?</li>
                                <li>What could improve?</li>
                                <li>Did you manage time well?</li>
                                <li>Did you cover all requirements?</li>
                                <li>Did you discuss trade-offs?</li>
                            </ul>
                        </div>
                    </div>

                    <div class="day-guide-card">
                        <div class="day-guide-header">
                            <span class="day-number-badge">Days 78-84</span>
                            <h4>Week 12: Company-Specific Preparation</h4>
                        </div>

                        <div class="concepts-section">
                            <h5>🎯 Research Target Companies:</h5>
                            <ul class="concepts-list">
                                <li><strong>Day 78-79: FAANG Deep Dive</strong>
                                    <ul>
                                        <li>Facebook/Meta: News feed, Stories, Ads platform</li>
                                        <li>Amazon: E-commerce, fulfillment, Prime Video</li>
                                        <li>Apple: iCloud, App Store, Apple Pay</li>
                                        <li>Netflix: Recommendation, streaming, encoding</li>
                                        <li>Google: Search, Maps, YouTube, Gmail</li>
                                    </ul>
                                </li>
                                <li><strong>Day 80-81: Unicorns & Startups</strong>
                                    <ul>
                                        <li>Uber: Ride matching, pricing, maps</li>
                                        <li>Airbnb: Search, booking, reviews</li>
                                        <li>Stripe: Payments, fraud detection</li>
                                        <li>Spotify: Music streaming, recommendations</li>
                                    </ul>
                                </li>
                                <li><strong>Day 82-83: Final Mock Interviews</strong>
                                    <ul>
                                        <li>Company-specific problems</li>
                                        <li>Simulate real interview conditions</li>
                                    </ul>
                                </li>
                                <li><strong>Day 84: Final Review</strong>
                                    <ul>
                                        <li>Review all concepts</li>
                                        <li>Practice capacity estimation</li>
                                        <li>Review trade-offs</li>
                                    </ul>
                                </li>
                            </ul>

                            <h5>💻 Final Preparation Checklist:</h5>
                            <ul class="practice-list">
                                <li>✓ Can do capacity estimation in 5 minutes?</li>
                                <li>✓ Know key formulas (QPS, storage, bandwidth)?</li>
                                <li>✓ Can explain CAP theorem with examples?</li>
                                <li>✓ Comfortable with trade-off discussions?</li>
                                <li>✓ Can draw clear architecture diagrams?</li>
                                <li>✓ Know when to use each database type?</li>
                                <li>✓ Understand caching strategies?</li>
                                <li>✓ Can design for scale (millions/billions)?</li>
                            </ul>
                        </div>
                    </div>

                    <div class="day-guide-card">
                        <div class="day-guide-header">
                            <span class="day-number-badge">Days 85-90</span>
                            <h4>Final Week: Polish & Confidence Building</h4>
                        </div>

                        <div class="concepts-section">
                            <h5>🎯 Daily Practice:</h5>
                            <ul class="concepts-list">
                                <li><strong>Day 85:</strong> Design Dropbox (File storage & sync)</li>
                                <li><strong>Day 86:</strong> Design Zoom (Video conferencing)</li>
                                <li><strong>Day 87:</strong> Design Tinder (Matching algorithm)</li>
                                <li><strong>Day 88:</strong> Design API Rate Limiter</li>
                                <li><strong>Day 89:</strong> Final mock interview - Random problem</li>
                                <li><strong>Day 90:</strong> Rest, review notes, boost confidence!</li>
                            </ul>

                            <h5>💻 Interview Day Preparation:</h5>
                            <ul class="practice-list">
                                <li><strong>Before Interview:</strong>
                                    <ul>
                                        <li>Review key formulas</li>
                                        <li>Prepare questions to ask interviewer</li>
                                        <li>Test video/audio setup</li>
                                        <li>Have paper/whiteboard ready</li>
                                    </ul>
                                </li>
                                <li><strong>During Interview:</strong>
                                    <ul>
                                        <li>Stay calm, think before speaking</li>
                                        <li>Clarify requirements thoroughly</li>
                                        <li>Manage time effectively</li>
                                        <li>Communicate trade-offs clearly</li>
                                    </ul>
                                </li>
                                <li><strong>After Interview:</strong>
                                    <ul>
                                        <li>Note what went well</li>
                                        <li>Note areas for improvement</li>
                                        <li>Don't overthink - prepare for next</li>
                                    </ul>
                                </li>
                            </ul>

                            <h5>🎯 Final Confidence Boosters:</h5>
                            <ul class="resources-list">
                                <li>You've completed 90 days of intensive prep! 🎉</li>
                                <li>You know more than 90% of candidates</li>
                                <li>Focus on demonstrating thinking process, not perfection</li>
                                <li>Every interview is practice - learn and improve</li>
                                <li>You've got this! 💪</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <!-- Summary & Resources -->
                <div class="study-guide-week">
                    <h3 class="week-header-guide">Quick Reference: Key Concepts Summary</h3>

                    <div class="day-guide-card">
                        <div class="day-guide-header">
                            <h4>Essential Formulas</h4>
                        </div>

                        <div class="concepts-section">
                            <ul class="concepts-list">
                                <li><strong>QPS:</strong> (DAU × Actions/User) / 86,400</li>
                                <li><strong>Storage:</strong> Items × Size_Per_Item × Retention_Days</li>
                                <li><strong>Bandwidth:</strong> QPS × Avg_Size × 8 / 1,000,000 (Mbps)</li>
                                <li><strong>Servers:</strong> Peak_QPS / QPS_Per_Server</li>
                                <li><strong>Cache Size:</strong> Total_Data × 0.2 (80-20 rule)</li>
                                <li><strong>Availability:</strong> 99.9% = 43.2 min downtime/month</li>
                            </ul>
                        </div>
                    </div>

                    <div class="day-guide-card">
                        <div class="day-guide-header">
                            <h4>Technology Decision Matrix</h4>
                        </div>

                        <div class="concepts-section">
                            <ul class="concepts-list">
                                <li><strong>Database:</strong> SQL (complex queries, ACID) vs NoSQL (scale, flexibility)
                                </li>
                                <li><strong>Cache:</strong> Redis (complex data) vs Memcached (simple key-value)</li>
                                <li><strong>Queue:</strong> Kafka (high throughput, replay) vs RabbitMQ (task queues)
                                </li>
                                <li><strong>Load Balancer:</strong> Layer 4 (performance) vs Layer 7 (content-based
                                    routing)</li>
                                <li><strong>Storage:</strong> Block (databases) vs Object (media) vs File (shared files)
                                </li>
                            </ul>
                        </div>
                    </div>
                </div>


            </div>

        </div>
    </main>

    <!-- Day Detail Modal -->
    <div class="modal" id="dayModal">
        <div class="modal-content">
            <div class="modal-header">
                <button class="modal-close" onclick="closeDayModal()">&times;</button>
                <h2 id="modalTitle">Day Details</h2>
                <p id="modalSubtitle" style="opacity: 0.9; margin-top: 0.5rem;"></p>
            </div>
            <div class="modal-body" id="modalBody">
                <!-- Day details will be populated by JavaScript -->
            </div>
        </div>
    </div>

    <script>
        // System Design Mastery Plan Data Structure
        const masterPlan = {
            weeks: [
                {
                    number: 1,
                    title: "Foundation & Prerequisites",
                    subtitle: "Days 1-7",
                    description: "Build solid foundations in programming, networking, databases, and system building blocks",
                    days: [
                        {
                            number: 1,
                            title: "Programming Fundamentals Review",
                            description: "OOP principles, data structures, complexity analysis",
                            theory: 45,
                            practice: 45,
                            topics: [
                                "Object-oriented programming principles",
                                "Data structures review (arrays, lists, hash tables, trees)",
                                "Time/space complexity basics"
                            ],
                            studyLinks: [
                                "Big O Notation Explained",
                                "OOP Principles"
                            ],
                            practiceItems: [
                                "Implement hash table with collision handling",
                                "Code binary search tree operations"
                            ],
                            problems: [
                                "LeetCode: #1 Two Sum",
                                "LeetCode: #217 Contains Duplicate"
                            ]
                        },
                        {
                            number: 2,
                            title: "Network Fundamentals",
                            description: "HTTP/HTTPS, TCP/UDP, client-server architecture",
                            theory: 60,
                            practice: 45,
                            topics: [
                                "HTTP/HTTPS protocols and status codes",
                                "TCP vs UDP differences",
                                "Client-server architecture basics",
                                "DNS resolution process"
                            ],
                            studyLinks: [
                                "HTTP Protocol Explained",
                                "TCP vs UDP"
                            ],
                            practiceItems: [
                                "Use curl commands to analyze HTTP headers",
                                "Set up simple client-server communication",
                                "Trace DNS queries using nslookup"
                            ],
                            miniProject: "Build basic HTTP client that displays response headers"
                        }
                        // Continue with remaining days...
                    ]
                }
                // Continue with remaining weeks...
            ]
        };

        // Initialize the application
        let completedDays = JSON.parse(localStorage.getItem('completedDays') || '[]');
        let currentProgress = JSON.parse(localStorage.getItem('currentProgress') || '{}');

        function showSection(sectionId) {
            // Hide all sections
            document.querySelectorAll('.section').forEach(section => {
                section.classList.remove('active');
            });

            // Show selected section
            document.getElementById(sectionId).classList.add('active');

            // Update navigation
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            event.target.classList.add('active');
        }

        function toggleDayCompletion(dayId) {
            const index = completedDays.indexOf(dayId);
            if (index > -1) {
                completedDays.splice(index, 1);
            } else {
                completedDays.push(dayId);
            }

            localStorage.setItem('completedDays', JSON.stringify(completedDays));
            updateProgress();
            renderWeeks();
        }

        function updateProgress() {
            const totalDays = 90;
            const completed = completedDays.length;
            const completionRate = Math.round((completed / totalDays) * 100);
            const currentWeek = Math.ceil((completed + 1) / 7);

            document.getElementById('completedDays').textContent = completed;
            document.getElementById('currentWeek').textContent = Math.min(currentWeek, 12);
            document.getElementById('completionRate').textContent = `${completionRate}%`;
        }

        function openDayModal(dayData) {
            const modal = document.getElementById('dayModal');
            const modalTitle = document.getElementById('modalTitle');
            const modalSubtitle = document.getElementById('modalSubtitle');
            const modalBody = document.getElementById('modalBody');

            modalTitle.textContent = `Day ${dayData.number}: ${dayData.title}`;
            modalSubtitle.textContent = dayData.description;

            let bodyContent = '';

            if (dayData.topics) {
                bodyContent += `
                    <div class="activity-section">
                        <h4>📚 Theory (${dayData.theory || 60} min)</h4>
                        <ul style="list-style: none; padding-left: 1rem;">
                            ${dayData.topics.map(topic => `<li style="margin-bottom: 0.5rem; padding-left: 1.5rem; position: relative;">
                                <span style="position: absolute; left: 0; color: var(--primary);">•</span>
                                ${topic}
                            </li>`).join('')}
                        </ul>
                    </div>
                `;
            }

            if (dayData.studyLinks) {
                bodyContent += `
                    <div class="activity-section">
                        <h4>🔗 Study Links</h4>
                        <div class="study-links">
                            ${dayData.studyLinks.map(link => `
                                <a href="#" class="study-link">
                                    <span style="margin-right: 0.75rem;">📖</span>
                                    ${link}
                                </a>
                            `).join('')}
                        </div>
                    </div>
                `;
            }

            if (dayData.practiceItems) {
                bodyContent += `
                    <div class="activity-section">
                        <h4>💻 Practice (${dayData.practice || 45} min)</h4>
                        <ul style="list-style: none; padding-left: 1rem;">
                            ${dayData.practiceItems.map(item => `<li style="margin-bottom: 0.75rem; padding: 1rem; background: #f8fafc; border-radius: 8px; border-left: 4px solid var(--success);">
                                ${item}
                            </li>`).join('')}
                        </ul>
                    </div>
                `;
            }

            if (dayData.problems) {
                bodyContent += `
                    <div class="activity-section">
                        <div class="problems-list">
                            <h5>🧩 Problems to Solve</h5>
                            <ul style="list-style: none; padding-left: 1rem; margin-top: 1rem;">
                                ${dayData.problems.map(problem => `<li style="margin-bottom: 0.5rem; padding-left: 1.5rem; position: relative;">
                                    <span style="position: absolute; left: 0; color: #92400e;">▶</span>
                                    ${problem}
                                </li>`).join('')}
                            </ul>
                        </div>
                    </div>
                `;
            }

            if (dayData.miniProject) {
                bodyContent += `
                    <div class="activity-section">
                        <h4>🚀 Mini Project</h4>
                        <div style="padding: 1.5rem; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border-radius: 12px; font-weight: 500;">
                            ${dayData.miniProject}
                        </div>
                    </div>
                `;
            }

            modalBody.innerHTML = bodyContent;
            modal.classList.add('active');
            document.body.style.overflow = 'hidden';
        }

        function closeDayModal() {
            const modal = document.getElementById('dayModal');
            modal.classList.remove('active');
            document.body.style.overflow = 'auto';
        }

        // Complete day data structure for all 90 days
        const completeProgram = {
            // Week 1: Foundation & Prerequisites (Days 1-7)
            week1: {
                number: 1,
                title: "Foundation & Prerequisites",
                subtitle: "Days 1-7",
                description: "Build solid foundations in programming, networking, databases, and system building blocks",
                days: [
                    {
                        number: 1,
                        title: "Programming Fundamentals Review",
                        description: "OOP principles, data structures, complexity analysis",
                        theory: 45,
                        practice: 45,
                        topics: [
                            "Object-oriented programming principles",
                            "Data structures review (arrays, lists, hash tables, trees)",
                            "Time/space complexity basics"
                        ],
                        studyLinks: [
                            "Big O Notation Explained",
                            "OOP Principles"
                        ],
                        practiceItems: [
                            "Implement hash table with collision handling",
                            "Code binary search tree operations"
                        ],
                        problems: [
                            "LeetCode: #1 Two Sum",
                            "LeetCode: #217 Contains Duplicate"
                        ]
                    },
                    {
                        number: 2,
                        title: "Network Fundamentals",
                        description: "HTTP/HTTPS, TCP/UDP, client-server architecture",
                        theory: 60,
                        practice: 45,
                        topics: [
                            "HTTP/HTTPS protocols and status codes",
                            "TCP vs UDP differences",
                            "Client-server architecture basics",
                            "DNS resolution process"
                        ],
                        studyLinks: [
                            "HTTP Protocol Explained",
                            "TCP vs UDP"
                        ],
                        practiceItems: [
                            "Use curl commands to analyze HTTP headers",
                            "Set up simple client-server communication",
                            "Trace DNS queries using nslookup"
                        ],
                        miniProject: "Build basic HTTP client that displays response headers"
                    },
                    {
                        number: 3,
                        title: "Database Fundamentals",
                        description: "ACID properties, SQL operations, schema design",
                        theory: 60,
                        practice: 45,
                        topics: [
                            "Relational database concepts",
                            "ACID properties with examples",
                            "Basic SQL operations and joins",
                            "Primary keys, foreign keys, indexes"
                        ],
                        studyLinks: [
                            "Database Fundamentals",
                            "ACID Properties Explained"
                        ],
                        practiceItems: [
                            "Design schema for simple e-commerce app",
                            "Write SQL queries with multiple joins",
                            "Create indexes and analyze query performance"
                        ],
                        problems: [
                            "Design database schema for Twitter-like app (users, tweets, follows)"
                        ]
                    },
                    {
                        number: 4,
                        title: "System Building Blocks Introduction",
                        description: "Architecture patterns, load balancers, caching, message queues",
                        theory: 60,
                        practice: 45,
                        topics: [
                            "Monolithic vs distributed architecture",
                            "Load balancers basics",
                            "Caching concepts",
                            "Message queues introduction"
                        ],
                        studyLinks: [
                            "System Design Primer - Scalability",
                            "Building Blocks Overview"
                        ],
                        practiceItems: [
                            "Draw architecture diagrams for simple web app",
                            "Compare different architectural approaches",
                            "Identify bottlenecks in sample systems"
                        ]
                    },
                    {
                        number: 5,
                        title: "Scalability Fundamentals",
                        description: "Horizontal vs vertical scaling, load distribution",
                        theory: 60,
                        practice: 45,
                        topics: [
                            "Horizontal vs vertical scaling",
                            "Stateless vs stateful services",
                            "Load distribution strategies",
                            "Basic performance metrics"
                        ],
                        studyLinks: [
                            "Scalability Principles",
                            "Stateless vs Stateful"
                        ],
                        practiceItems: [
                            "Design scaling strategy for growing web app",
                            "Calculate capacity requirements",
                            "Identify scaling bottlenecks"
                        ],
                        problems: [
                            "Design system to handle 1M users vs 100M users"
                        ]
                    },
                    {
                        number: 6,
                        title: "Introduction to Distributed Systems",
                        description: "Challenges, network partitions, consistency, fault tolerance",
                        theory: 60,
                        practice: 45,
                        topics: [
                            "Distributed system challenges",
                            "Network partitions",
                            "Consistency basics",
                            "Fault tolerance concepts"
                        ],
                        studyLinks: [
                            "Distributed Systems Basics",
                            "CAP Theorem Introduction"
                        ],
                        practiceItems: [
                            "Design fault-tolerant system",
                            "Analyze failure scenarios",
                            "Plan recovery strategies"
                        ]
                    },
                    {
                        number: 7,
                        title: "Week 1 Review & Assessment",
                        description: "Review concepts and build mini URL shortener",
                        theory: 60,
                        practice: 90,
                        topics: [
                            "Review all concepts from Week 1"
                        ],
                        practiceItems: [
                            "Build mini URL shortener (basic version)"
                        ],
                        assessment: "Explain system design concepts to someone else"
                    }
                ]
            },

            // Updated Week 2: Core System Components (Days 8-14)
            // Added: Consistent hashing, Bloom filters, Rate limiting deep dive

            week2: {
                number: 2,
                title: "Core System Components",
                subtitle: "Days 8-14",
                description: "Deep dive into databases, caching, load balancing, and essential system components",
                days: [
                    {
                        number: 8,
                        title: "Database Deep Dive",
                        description: "Replication, sharding, consistent hashing, NoSQL, connection pooling",
                        theory: 75,
                        practice: 60,
                        topics: [
                            "Database replication (master-slave, master-master)",
                            "Sharding strategies",
                            "Consistent hashing for data distribution",
                            "NoSQL introduction (document, key-value, column-family)",
                            "Database connection pooling"
                        ],
                        studyLinks: [
                            "Database Replication",
                            "NoSQL Databases",
                            "Consistent Hashing Explained"
                        ],
                        practiceItems: [
                            "Set up MySQL master-slave replication",
                            "Design sharding strategy for user data",
                            "Implement consistent hashing algorithm for distributed cache",
                            "Compare PostgreSQL vs MongoDB for different use cases"
                        ],
                        problems: [
                            "Design database architecture for social media platform (10M users)",
                            "Implement consistent hashing ring with virtual nodes"
                        ]
                    },
                    {
                        number: 9,
                        title: "Caching Systems",
                        description: "Cache patterns, levels, bloom filters, invalidation strategies",
                        theory: 75,
                        practice: 60,
                        topics: [
                            "Cache patterns (cache-aside, write-through, write-behind)",
                            "Cache levels (browser, CDN, application, database)",
                            "Bloom filters for cache optimization",
                            "Cache invalidation strategies",
                            "Redis vs Memcached"
                        ],
                        studyLinks: [
                            "Caching Patterns",
                            "Redis Documentation",
                            "Bloom Filter Applications"
                        ],
                        practiceItems: [
                            "Implement LRU cache from scratch",
                            "Implement bloom filter to reduce cache misses",
                            "Set up Redis with different eviction policies",
                            "Measure cache hit ratios",
                            "Use bloom filter to check cache before querying database"
                        ],
                        problems: [
                            "Design caching strategy for e-commerce product catalog",
                            "When would you use bloom filters vs regular cache?"
                        ]
                    },
                    {
                        number: 10,
                        title: "Load Balancing & Rate Limiting",
                        description: "Layer 4 vs 7, algorithms, rate limiting, health checks, failover",
                        theory: 75,
                        practice: 75,
                        topics: [
                            "Layer 4 vs Layer 7 load balancing",
                            "Load balancing algorithms (round-robin, least connections, weighted)",
                            "Rate limiting algorithms (token bucket, leaky bucket, sliding window, fixed window)",
                            "Health checks and failover",
                            "Sticky sessions"
                        ],
                        studyLinks: [
                            "Load Balancing Concepts",
                            "HAProxy Documentation",
                            "Rate Limiting Algorithms Compared"
                        ],
                        practiceItems: [
                            "Configure Nginx as load balancer",
                            "Set up HAProxy with health checks",
                            "Implement token bucket rate limiter",
                            "Implement sliding window rate limiter",
                            "Compare performance of different rate limiting algorithms",
                            "Test failover scenarios"
                        ],
                        problems: [
                            "Design load balancing for global web service",
                            "Design API rate limiting system for 1M requests/sec"
                        ]
                    },
                    {
                        number: 11,
                        title: "Message Queues & Async Processing",
                        description: "Queue patterns, durability, delivery guarantees",
                        theory: 60,
                        practice: 60,
                        topics: [
                            "Queue vs topic patterns",
                            "Message durability and delivery guarantees",
                            "Dead letter queues",
                            "Backpressure handling"
                        ],
                        studyLinks: [
                            "Message Queue Patterns",
                            "RabbitMQ Tutorial"
                        ],
                        practiceItems: [
                            "Build simple message queue system",
                            "Implement pub/sub with Redis",
                            "Handle message failures gracefully"
                        ],
                        problems: [
                            "Design order processing system with queues"
                        ]
                    },
                    {
                        number: 12,
                        title: "CDN & Content Delivery",
                        description: "Edge caching, distribution strategies, invalidation",
                        theory: 60,
                        practice: 60,
                        topics: [
                            "CDN architecture and benefits",
                            "Pull vs push CDNs",
                            "Cache invalidation strategies",
                            "Multi-region content distribution"
                        ],
                        studyLinks: [
                            "CDN Fundamentals",
                            "CloudFlare Architecture"
                        ],
                        practiceItems: [
                            "Set up basic CDN with nginx",
                            "Configure cache headers",
                            "Implement cache invalidation"
                        ],
                        problems: [
                            "Design CDN strategy for global video platform"
                        ]
                    },
                    {
                        number: 13,
                        title: "Storage Systems",
                        description: "Object storage, file systems, blob storage",
                        theory: 60,
                        practice: 60,
                        topics: [
                            "Object storage (S3-style)",
                            "Distributed file systems (HDFS, GFS)",
                            "Blob storage architecture",
                            "Data deduplication"
                        ],
                        studyLinks: [
                            "Object Storage Design",
                            "HDFS Architecture"
                        ],
                        practiceItems: [
                            "Design object storage system",
                            "Implement file chunking and metadata",
                            "Build simple distributed file system"
                        ],
                        problems: [
                            "Design Dropbox/Google Drive storage backend"
                        ]
                    },
                    {
                        number: 14,
                        title: "Week 2 Review & Integration",
                        description: "Build comprehensive system using Week 2 components",
                        theory: 60,
                        practice: 120,
                        topics: [
                            "Review all Week 2 concepts",
                            "Component integration patterns"
                        ],
                        practiceItems: [
                            "Build e-commerce backend with database, cache, load balancer, and CDN"
                        ],
                        assessment: "Explain trade-offs between different caching strategies and when to use bloom filters"
                    }
                ]
            },

            // Updated Week 3: Distributed Systems & Advanced Patterns (Days 15-21)
            // Added: Trade-off framework, Back-of-envelope calculations

            week3: {
                number: 3,
                title: "Distributed Systems & Advanced Patterns",
                subtitle: "Days 15-21",
                description: "Master distributed systems concepts, consistency models, and advanced architectural patterns",
                days: [
                    {
                        number: 15,
                        title: "CAP Theorem & Trade-off Analysis",
                        description: "Consistency, availability, partition tolerance, trade-off frameworks",
                        theory: 75,
                        practice: 60,
                        topics: [
                            "CAP theorem deep dive",
                            "Consistency models (strong, eventual, causal)",
                            "Trade-off Analysis Framework",
                            "Consistency vs Availability vs Partition tolerance",
                            "Latency vs Throughput trade-offs",
                            "Cost vs Performance trade-offs",
                            "Read-heavy vs Write-heavy optimizations"
                        ],
                        studyLinks: [
                            "CAP Theorem Explained",
                            "Consistency Models",
                            "System Design Trade-offs"
                        ],
                        practiceItems: [
                            "Compare CP vs AP systems",
                            "Design system choosing appropriate consistency model",
                            "Apply trade-off framework to analyze 3 different system designs",
                            "Document trade-offs for Instagram, Netflix, and banking system",
                            "Create decision matrix for choosing consistency levels"
                        ],
                        problems: [
                            "Design system that prioritizes availability over consistency (social media)",
                            "Design system that requires strong consistency (banking)",
                            "Analyze trade-offs: Should Twitter favor consistency or availability?"
                        ],
                        interviewFocus: "Be able to clearly explain trade-offs and justify your design decisions"
                    },
                    {
                        number: 16,
                        title: "Distributed Transactions",
                        description: "2PC, 3PC, Saga pattern, eventual consistency",
                        theory: 60,
                        practice: 60,
                        topics: [
                            "Two-phase commit (2PC)",
                            "Three-phase commit (3PC)",
                            "Saga pattern",
                            "Eventual consistency patterns"
                        ],
                        studyLinks: [
                            "Distributed Transactions",
                            "Saga Pattern"
                        ],
                        practiceItems: [
                            "Implement 2PC protocol",
                            "Design saga for order processing",
                            "Handle compensation logic"
                        ],
                        problems: [
                            "Design distributed transaction system for payment processing"
                        ]
                    },
                    {
                        number: 17,
                        title: "Replication & Consensus",
                        description: "Leader election, Paxos, Raft, quorum",
                        theory: 60,
                        practice: 60,
                        topics: [
                            "Leader election algorithms",
                            "Paxos consensus",
                            "Raft consensus (simplified)",
                            "Quorum reads/writes"
                        ],
                        studyLinks: [
                            "Raft Consensus",
                            "Distributed Consensus"
                        ],
                        practiceItems: [
                            "Simulate leader election",
                            "Implement basic Raft",
                            "Design quorum-based system"
                        ],
                        problems: [
                            "Design distributed key-value store with consensus"
                        ]
                    },
                    {
                        number: 18,
                        title: "Microservices & Capacity Planning",
                        description: "Service design, communication, discovery, capacity estimation",
                        theory: 75,
                        practice: 75,
                        topics: [
                            "Microservices vs monolith",
                            "Service boundaries and domain-driven design",
                            "Inter-service communication patterns",
                            "Service discovery mechanisms",
                            "Back-of-envelope Calculations Framework",
                            "QPS (Queries Per Second) calculations",
                            "Storage estimation techniques",
                            "Bandwidth requirements calculation",
                            "Server capacity planning",
                            "Memory and CPU estimation"
                        ],
                        studyLinks: [
                            "Microservices Patterns",
                            "Service Discovery",
                            "Capacity Planning Guide",
                            "Back-of-envelope Calculations"
                        ],
                        practiceItems: [
                            "Break monolithic app into microservices",
                            "Implement service discovery",
                            "Design API gateway",
                            "Calculate infrastructure needs for 100M users",
                            "Estimate storage for video platform (1M videos/day)",
                            "Calculate required servers for peak load (10K QPS)",
                            "Estimate bandwidth for image sharing platform",
                            "Calculate cache size for hot data"
                        ],
                        problems: [
                            "Convert e-commerce monolith to microservices",
                            "Calculate: How many servers needed for Twitter (500M users, 300M DAU, avg 5 tweets/day)?",
                            "Calculate: Storage needed for WhatsApp (2B users, 50 messages/user/day, 5 year retention)?",
                            "Estimate: Database shards needed for Instagram (1B users, 100M photos/day)?"
                        ],
                        resources: [
                            "Use powers of 2 for estimates (1K ≈ 10³, 1M ≈ 10⁶, 1B ≈ 10⁹)",
                            "Standard assumptions: 1 char = 1 byte, 1 int = 4 bytes, QPS = Daily active users × actions per user / 86400"
                        ],
                        interviewFocus: "Practice calculating on whiteboard quickly with reasonable assumptions"
                    },
                    {
                        number: 19,
                        title: "Event-Driven Architecture",
                        description: "Event sourcing, CQRS, event streaming, saga patterns",
                        theory: 60,
                        practice: 60,
                        topics: [
                            "Event sourcing patterns",
                            "CQRS (Command Query Responsibility Segregation)",
                            "Event streaming with Kafka",
                            "Saga patterns for distributed transactions"
                        ],
                        studyLinks: [
                            "Event-Driven Architecture",
                            "Event Sourcing"
                        ],
                        practiceItems: [
                            "Design event-driven order system",
                            "Implement simple event sourcing",
                            "Create event streaming pipeline"
                        ],
                        problems: [
                            "Design event-driven banking transaction system"
                        ]
                    },
                    {
                        number: 20,
                        title: "Observability & Monitoring",
                        description: "Metrics, logs, traces, distributed tracing, SLI/SLO/SLA",
                        theory: 60,
                        practice: 60,
                        topics: [
                            "Three pillars: metrics, logs, traces",
                            "Distributed tracing concepts",
                            "SLI/SLO/SLA definitions",
                            "Alerting best practices"
                        ],
                        studyLinks: [
                            "Observability Engineering",
                            "Distributed Tracing"
                        ],
                        practiceItems: [
                            "Set up Prometheus + Grafana",
                            "Implement distributed tracing with Jaeger",
                            "Create custom metrics and alerts"
                        ],
                        problems: [
                            "Design monitoring for microservices platform"
                        ]
                    },
                    {
                        number: 21,
                        title: "Week 3 Review & Advanced Project",
                        description: "Distributed chat system with capacity planning",
                        theory: 60,
                        practice: 120,
                        topics: [
                            "Review distributed systems concepts",
                            "Apply trade-off analysis",
                            "Calculate system capacity"
                        ],
                        practiceItems: [
                            "Distributed chat system with multiple components",
                            "Calculate: servers, storage, bandwidth needed for 50M users",
                            "Document all design trade-offs and justify decisions"
                        ],
                        assessment: "Design Instagram-like system with full capacity calculations and trade-off analysis"
                    }
                ]
            },

            // Updated Week 4: Modern Architecture Patterns (Days 22-28)
            // Added: Geospatial indexing as Day 25.5

            week4: {
                number: 4,
                title: "Modern Architecture Patterns",
                subtitle: "Days 22-28",
                description: "Explore cloud-native architecture, API design, search systems, geospatial indexing, and AI/ML integration",
                days: [
                    {
                        number: 22,
                        title: "Cloud-Native Architecture",
                        description: "12-factor app, Kubernetes, service mesh, serverless",
                        theory: 60,
                        practice: 60,
                        topics: [
                            "12-factor app methodology",
                            "Container orchestration with Kubernetes",
                            "Service mesh concepts (Istio, Linkerd)",
                            "Serverless architecture patterns"
                        ],
                        studyLinks: [
                            "12-Factor App",
                            "Kubernetes Concepts",
                            "Service Mesh"
                        ],
                        practiceItems: [
                            "Deploy app on Kubernetes",
                            "Configure service mesh",
                            "Build serverless function"
                        ],
                        problems: [
                            "Design cloud-native e-commerce platform"
                        ]
                    },
                    {
                        number: 23,
                        title: "API Design & Management",
                        description: "RESTful design, GraphQL vs REST, versioning, rate limiting",
                        theory: 60,
                        practice: 60,
                        topics: [
                            "RESTful API design principles",
                            "GraphQL vs REST trade-offs",
                            "API versioning strategies",
                            "Rate limiting and throttling",
                            "API gateway patterns"
                        ],
                        studyLinks: [
                            "REST API Design",
                            "GraphQL Introduction",
                            "API Gateway Patterns"
                        ],
                        practiceItems: [
                            "Design RESTful API for social platform",
                            "Implement GraphQL endpoint",
                            "Set up API gateway with rate limiting"
                        ],
                        problems: [
                            "Design API strategy for mobile banking app"
                        ]
                    },
                    {
                        number: 24,
                        title: "Search & Indexing Systems",
                        description: "Full-text search, Elasticsearch, ranking algorithms, auto-complete",
                        theory: 60,
                        practice: 60,
                        topics: [
                            "Full-text search concepts",
                            "Elasticsearch architecture",
                            "Search ranking algorithms",
                            "Auto-complete and suggestions",
                            "Inverted indexes"
                        ],
                        studyLinks: [
                            "Elasticsearch Guide",
                            "Search Engine Architecture"
                        ],
                        practiceItems: [
                            "Set up Elasticsearch cluster",
                            "Index documents and implement search",
                            "Build auto-complete functionality"
                        ],
                        problems: [
                            "Design search system for e-commerce with 100M products"
                        ]
                    },
                    {
                        number: 25,
                        title: "Real-time Systems",
                        description: "WebSocket vs SSE, messaging patterns, push notifications",
                        theory: 60,
                        practice: 60,
                        topics: [
                            "WebSocket vs Server-Sent Events",
                            "Real-time messaging patterns",
                            "Push notification systems",
                            "Long polling vs WebSockets"
                        ],
                        studyLinks: [
                            "WebSocket Guide",
                            "Real-time Architecture"
                        ],
                        practiceItems: [
                            "Build WebSocket chat server",
                            "Implement push notification system",
                            "Compare polling vs WebSocket performance"
                        ],
                        problems: [
                            "Design real-time collaborative editing (Google Docs)"
                        ]
                    },
                    {
                        number: 26,
                        title: "Geospatial Systems & Location Services",
                        description: "Geospatial indexing, proximity search, location-based services",
                        theory: 75,
                        practice: 75,
                        topics: [
                            "Geospatial data structures (Quadtree, R-tree, Geohash)",
                            "Proximity search algorithms",
                            "Location-based indexing strategies",
                            "Distance calculations (Haversine formula)",
                            "Geofencing and region queries",
                            "H3 hexagonal hierarchical spatial index"
                        ],
                        studyLinks: [
                            "Geospatial Indexing Guide",
                            "Quadtree Explained",
                            "Geohash vs H3",
                            "PostGIS Documentation"
                        ],
                        practiceItems: [
                            "Implement quadtree for location data",
                            "Build proximity search system ('find nearby')",
                            "Implement geohash encoding/decoding",
                            "Calculate distances using Haversine formula",
                            "Design location update handling at scale"
                        ],
                        problems: [
                            "Design Yelp's 'nearby restaurants' feature",
                            "Design Uber's driver-rider matching based on location",
                            "Design geofencing system for location-based notifications",
                            "Calculate: How to index 1M restaurant locations for fast proximity queries?"
                        ],
                        interviewFocus: "Understand when to use Quadtree vs Geohash vs database solutions (PostGIS)",
                        resources: [
                            "Quadtree: Good for dynamic data with frequent updates",
                            "Geohash: Good for static data, enables range queries",
                            "R-tree: Best for complex shapes and polygons",
                            "Database approach: PostgreSQL + PostGIS for simpler use cases"
                        ]
                    },
                    {
                        number: 27,
                        title: "AI/ML Integration in System Design",
                        description: "Model serving, feature stores, ML pipelines, A/B testing",
                        theory: 60,
                        practice: 60,
                        topics: [
                            "ML model serving architecture",
                            "Feature stores and pipelines",
                            "Online vs offline predictions",
                            "A/B testing frameworks",
                            "Model monitoring and retraining"
                        ],
                        studyLinks: [
                            "ML System Design",
                            "Feature Store Architecture"
                        ],
                        practiceItems: [
                            "Design model serving infrastructure",
                            "Build simple feature pipeline",
                            "Implement A/B testing framework"
                        ],
                        problems: [
                            "Design recommendation system with ML"
                        ]
                    },
                    {
                        number: 28,
                        title: "Week 4 Review & Comprehensive Design",
                        description: "Design modern application with all Week 4 patterns",
                        theory: 60,
                        practice: 120,
                        topics: [
                            "Review all modern patterns",
                            "Integration of cloud-native, APIs, search, geospatial, and ML"
                        ],
                        practiceItems: [
                            "Design food delivery platform (combines APIs, geospatial, real-time, ML)",
                            "Include: API design, location services, real-time tracking, recommendations",
                            "Calculate capacity and document trade-offs"
                        ],
                        assessment: "Present complete system design with all components integrated"
                    }
                ]
            },
            // Week 5-8: System Design Problems Practice (Days 29-56)
            week5: {
                number: 5,
                title: "Classic System Design Problems",
                subtitle: "Days 29-35",
                description: "Master fundamental system design problems with hands-on implementation",
                days: [
                    {
                        number: 29,
                        title: "URL Shortener - Design & Planning",
                        description: "Requirements gathering, database schema, high-level architecture",
                        theory: 120,
                        practice: 0,
                        topics: [
                            "Requirements gathering and estimation",
                            "Database schema design",
                            "High-level architecture",
                            "API design"
                        ],
                        studyLinks: [
                            "URL Shortener Design",
                            "Bit.ly Architecture"
                        ],
                        practiceItems: [
                            "Define functional and non-functional requirements",
                            "Calculate capacity and storage requirements",
                            "Design database schema for URLs and users",
                            "Create API specification"
                        ]
                    },
                    {
                        number: 30,
                        title: "URL Shortener - Implementation & Scaling",
                        description: "Build prototype, add caching, handle 1B URLs/day",
                        theory: 0,
                        practice: 120,
                        topics: [
                            "Building working prototype",
                            "Adding caching layer",
                            "Planning for 1B URLs/day",
                            "Handling custom URLs"
                        ],
                        practiceItems: [
                            "Implement basic URL shortening service",
                            "Add Redis caching layer",
                            "Design sharding strategy for scale",
                            "Implement custom URL feature"
                        ],
                        problems: [
                            "Design TinyURL with analytics"
                        ]
                    },
                    {
                        number: 31,
                        title: "Chat System - Core Features",
                        description: "Message delivery, presence indicators, push notifications",
                        theory: 120,
                        practice: 0,
                        topics: [
                            "Message delivery guarantees",
                            "Online presence indicators",
                            "Push notification system",
                            "End-to-end encryption basics"
                        ],
                        studyLinks: [
                            "WhatsApp Architecture",
                            "Chat System Design"
                        ],
                        practiceItems: [
                            "Design message delivery system",
                            "Implement presence tracking",
                            "Plan push notification architecture",
                            "Basic encryption implementation"
                        ]
                    },
                    {
                        number: 32,
                        title: "Chat System - Advanced Features",
                        description: "Group chat scaling, synchronization, media sharing",
                        theory: 0,
                        practice: 120,
                        topics: [
                            "Group chat scaling",
                            "Message synchronization",
                            "Media sharing",
                            "Status updates"
                        ],
                        practiceItems: [
                            "Implement group chat functionality",
                            "Build message sync across devices",
                            "Design media upload/download system",
                            "Add status update features"
                        ],
                        problems: [
                            "Design Slack with channels and threading"
                        ]
                    },
                    {
                        number: 33,
                        title: "Social Media Feed - Feed Generation",
                        description: "Fan-out strategies, timeline algorithms, celebrity handling",
                        theory: 120,
                        practice: 0,
                        topics: [
                            "Fan-out strategies (push vs pull)",
                            "Timeline generation algorithms",
                            "Celebrity user handling",
                            "Content ranking"
                        ],
                        studyLinks: [
                            "Twitter Architecture",
                            "News Feed Design"
                        ],
                        practiceItems: [
                            "Implement push-based feed generation",
                            "Design pull-based feed system",
                            "Handle celebrity user posts",
                            "Build content ranking algorithm"
                        ]
                    },
                    {
                        number: 34,
                        title: "Social Media Feed - Scaling & Features",
                        description: "Handle 300M users, trending topics, media content",
                        theory: 0,
                        practice: 120,
                        topics: [
                            "Handling 300M users",
                            "Trending topics",
                            "Media content delivery",
                            "Spam detection"
                        ],
                        practiceItems: [
                            "Scale feed system to 300M users",
                            "Implement trending topics algorithm",
                            "Design media CDN strategy",
                            "Build spam detection system"
                        ],
                        problems: [
                            "Design Instagram feed with stories"
                        ]
                    },
                    {
                        number: 35,
                        title: "Week 5 Review & Mock Interview",
                        description: "Practice problems with timer and identify improvement areas",
                        theory: 60,
                        practice: 120,
                        topics: [
                            "Review all Week 5 concepts"
                        ],
                        practiceItems: [
                            "Timed mock interview practice",
                            "Self-assessment and improvement planning"
                        ],
                        assessment: "Practice one of the above problems with timer"
                    }
                ]
            },

            week6: {
                number: 6,
                title: "Advanced Applications",
                subtitle: "Days 36-42",
                description: "Design complex systems like video streaming, ride sharing, and search engines",
                days: [
                    {
                        number: 36,
                        title: "Video Streaming - Core Infrastructure",
                        description: "Video encoding, CDN strategy, recommendation basics",
                        theory: 120,
                        practice: 0,
                        topics: [
                            "Video encoding and transcoding",
                            "CDN strategy for video delivery",
                            "Recommendation system basics",
                            "View count consistency"
                        ],
                        studyLinks: [
                            "YouTube Architecture",
                            "Video Streaming Design"
                        ],
                        practiceItems: [
                            "Design video encoding pipeline",
                            "Plan global CDN for video content",
                            "Implement basic recommendation engine",
                            "Handle view count at scale"
                        ]
                    },
                    {
                        number: 37,
                        title: "Video Streaming - Advanced Features",
                        description: "Live streaming, comments, monetization, moderation",
                        theory: 0,
                        practice: 120,
                        topics: [
                            "Live streaming capabilities",
                            "Comments and engagement",
                            "Creator monetization",
                            "Content moderation"
                        ],
                        practiceItems: [
                            "Build live streaming infrastructure",
                            "Implement real-time comments system",
                            "Design monetization platform",
                            "Create content moderation pipeline"
                        ]
                    },
                    {
                        number: 38,
                        title: "Ride Sharing - Core Matching",
                        description: "Driver-rider matching, location tracking, ETA calculation",
                        theory: 120,
                        practice: 0,
                        topics: [
                            "Driver-rider matching algorithms",
                            "Real-time location tracking",
                            "ETA calculation",
                            "Dynamic pricing"
                        ],
                        studyLinks: [
                            "Uber Engineering Blog",
                            "Uber System Design"
                        ],
                        practiceItems: [
                            "Implement matching algorithm",
                            "Build location tracking system",
                            "Calculate ETA with traffic data",
                            "Design dynamic pricing model"
                        ]
                    },
                    {
                        number: 39,
                        title: "Ride Sharing - Advanced Operations",
                        description: "Supply-demand balancing, route optimization, payments",
                        theory: 0,
                        practice: 120,
                        topics: [
                            "Supply-demand balancing",
                            "Route optimization",
                            "Payment processing",
                            "Surge pricing algorithms"
                        ],
                        practiceItems: [
                            "Build supply-demand prediction",
                            "Implement route optimization",
                            "Design payment processing system",
                            "Create surge pricing algorithm"
                        ]
                    },
                    {
                        number: 40,
                        title: "Search Engine - Crawling & Indexing",
                        description: "Web crawling strategies, distributed indexing, link analysis",
                        theory: 120,
                        practice: 0,
                        topics: [
                            "Web crawling strategies",
                            "Distributed indexing",
                            "Link analysis algorithms",
                            "Search ranking factors"
                        ],
                        studyLinks: [
                            "Google Search Architecture",
                            "Search System Design"
                        ],
                        practiceItems: [
                            "Build web crawler",
                            "Design distributed indexing system",
                            "Implement PageRank algorithm",
                            "Create ranking factors"
                        ]
                    },
                    {
                        number: 41,
                        title: "Search Engine - Query Processing",
                        description: "Query understanding, result ranking, auto-complete",
                        theory: 0,
                        practice: 120,
                        topics: [
                            "Query understanding",
                            "Result ranking and personalization",
                            "Auto-complete systems",
                            "Cache optimization"
                        ],
                        practiceItems: [
                            "Build query parser",
                            "Implement result ranking",
                            "Create auto-complete system",
                            "Optimize search cache"
                        ]
                    },
                    {
                        number: 42,
                        title: "Week 6 Review & Assessment",
                        description: "Comprehensive review and Netflix-like system design",
                        theory: 60,
                        practice: 120,
                        topics: [
                            "Review all systems covered so far"
                        ],
                        practiceItems: [
                            "Design Netflix-like streaming service"
                        ],
                        assessment: "Comprehensive system design assessment"
                    }
                ]
            },

            week7: {
                number: 7,
                title: "Specialized Systems",
                subtitle: "Days 43-49",
                description: "Master e-commerce, financial trading, and gaming platform architectures",
                days: [
                    {
                        number: 43,
                        title: "E-commerce Platform - Core Commerce",
                        description: "Product catalog, inventory management, shopping cart, order processing",
                        theory: 120,
                        practice: 0,
                        topics: [
                            "Product catalog design",
                            "Inventory management",
                            "Shopping cart and checkout",
                            "Order processing pipeline"
                        ],
                        practiceItems: [
                            "Design product catalog system",
                            "Build inventory management",
                            "Implement shopping cart",
                            "Create order processing workflow"
                        ]
                    },
                    {
                        number: 44,
                        title: "E-commerce Platform - Advanced Features",
                        description: "Recommendations, price optimization, fraud detection, global scaling",
                        theory: 0,
                        practice: 120,
                        topics: [
                            "Recommendation engines",
                            "Price optimization",
                            "Fraud detection",
                            "Global marketplace scaling"
                        ],
                        practiceItems: [
                            "Build recommendation system",
                            "Implement dynamic pricing",
                            "Create fraud detection pipeline",
                            "Scale to global marketplace"
                        ]
                    },
                    {
                        number: 45,
                        title: "Financial Trading System - Core Trading",
                        description: "Order matching engines, price feeds, risk management",
                        theory: 120,
                        practice: 0,
                        topics: [
                            "Order matching engines",
                            "Real-time price feeds",
                            "Risk management systems",
                            "Regulatory compliance"
                        ],
                        practiceItems: [
                            "Build order matching engine",
                            "Design price feed system",
                            "Implement risk management",
                            "Ensure regulatory compliance"
                        ]
                    },
                    {
                        number: 46,
                        title: "Financial Trading System - Advanced Trading",
                        description: "High-frequency trading, market data, settlement systems",
                        theory: 0,
                        practice: 120,
                        topics: [
                            "High-frequency trading optimization",
                            "Market data distribution",
                            "Settlement systems",
                            "Cross-border transactions"
                        ],
                        practiceItems: [
                            "Optimize for high-frequency trading",
                            "Build market data distribution",
                            "Design settlement system",
                            "Handle cross-border transactions"
                        ]
                    },
                    {
                        number: 47,
                        title: "Gaming Platform - Core Gaming",
                        description: "Multiplayer architecture, game state sync, cheat detection",
                        theory: 120,
                        practice: 0,
                        topics: [
                            "Real-time multiplayer architecture",
                            "Game state synchronization",
                            "Cheat detection systems",
                            "Matchmaking algorithms"
                        ],
                        practiceItems: [
                            "Build multiplayer game server",
                            "Implement state synchronization",
                            "Create cheat detection system",
                            "Design matchmaking algorithm"
                        ]
                    },
                    {
                        number: 48,
                        title: "Gaming Platform - Platform Features",
                        description: "Leaderboards, tournaments, in-game purchases, social features",
                        theory: 0,
                        practice: 120,
                        topics: [
                            "Leaderboards and tournaments",
                            "In-game purchases",
                            "Social features",
                            "Content delivery"
                        ],
                        practiceItems: [
                            "Build leaderboard system",
                            "Implement in-game purchases",
                            "Add social gaming features",
                            "Optimize content delivery"
                        ]
                    },
                    {
                        number: 49,
                        title: "Week 7 Review & Specialization Choice",
                        description: "Review and choose specialization area for deep dive",
                        theory: 60,
                        practice: 120,
                        topics: [
                            "Identify your strongest interest area",
                            "Deep dive into chosen specialization"
                        ],
                        practiceItems: [
                            "Design system in your preferred domain"
                        ],
                        assessment: "Specialization-focused system design"
                    }
                ]
            },

            week8: {
                number: 8,
                title: "Integration & AI-Enhanced Systems",
                subtitle: "Days 50-56",
                description: "Integrate AI/ML systems and prepare for intensive interview practice",
                days: [
                    {
                        number: 50,
                        title: "AI-Powered Recommendation System - ML Integration",
                        description: "Feature engineering, model serving, A/B testing, cold start",
                        theory: 120,
                        practice: 0,
                        topics: [
                            "Feature engineering pipelines",
                            "Model training and serving",
                            "A/B testing frameworks",
                            "Cold start problems"
                        ],
                        studyLinks: [
                            "Netflix Recommendation System",
                            "ML System Design Interview"
                        ],
                        practiceItems: [
                            "Build feature engineering pipeline",
                            "Deploy ML model serving",
                            "Implement A/B testing framework",
                            "Solve cold start problem"
                        ]
                    },
                    {
                        number: 51,
                        title: "AI-Powered Recommendation System - Advanced ML",
                        description: "Real-time personalization, multi-armed bandits, model monitoring",
                        theory: 0,
                        practice: 120,
                        topics: [
                            "Real-time personalization",
                            "Multi-armed bandit algorithms",
                            "Explainability and fairness",
                            "Model monitoring and drift detection"
                        ],
                        practiceItems: [
                            "Implement real-time personalization",
                            "Build multi-armed bandit system",
                            "Add explainability features",
                            "Create model monitoring"
                        ]
                    },
                    {
                        number: 52,
                        title: "Content Moderation System - Automated Moderation",
                        description: "AI-powered classification, image/video analysis, text sentiment",
                        theory: 120,
                        practice: 0,
                        topics: [
                            "AI-powered content classification",
                            "Image and video analysis",
                            "Text sentiment analysis",
                            "Spam detection algorithms"
                        ],
                        practiceItems: [
                            "Build content classification system",
                            "Implement image/video analysis",
                            "Create sentiment analysis",
                            "Design spam detection"
                        ]
                    },
                    {
                        number: 53,
                        title: "Content Moderation System - Human-in-the-Loop",
                        description: "Escalation workflows, reviewer tools, appeal processes",
                        theory: 0,
                        practice: 120,
                        topics: [
                            "Escalation workflows",
                            "Reviewer tools and interfaces",
                            "Appeal processes",
                            "Policy enforcement"
                        ],
                        practiceItems: [
                            "Design escalation system",
                            "Build reviewer interface",
                            "Implement appeal process",
                            "Create policy enforcement"
                        ]
                    },
                    {
                        number: 54,
                        title: "IoT Platform - Device Management",
                        description: "Device provisioning, time-series data, monitoring, edge computing",
                        theory: 120,
                        practice: 0,
                        topics: [
                            "Device provisioning and authentication",
                            "Time-series data ingestion",
                            "Real-time monitoring dashboards",
                            "Edge computing integration"
                        ],
                        practiceItems: [
                            "Build device provisioning system",
                            "Design time-series data pipeline",
                            "Create monitoring dashboard",
                            "Implement edge computing"
                        ]
                    },
                    {
                        number: 55,
                        title: "IoT Platform - Analytics & Automation",
                        description: "Predictive maintenance, anomaly detection, automated responses",
                        theory: 0,
                        practice: 120,
                        topics: [
                            "Predictive maintenance algorithms",
                            "Anomaly detection systems",
                            "Automated response systems",
                            "Data retention policies"
                        ],
                        practiceItems: [
                            "Build predictive maintenance",
                            "Implement anomaly detection",
                            "Create automated responses",
                            "Design data retention"
                        ]
                    },
                    {
                        number: 56,
                        title: "Week 8 Review & Integration Assessment",
                        description: "Review specialized systems and prepare for interview practice",
                        theory: 60,
                        practice: 120,
                        topics: [
                            "Review all specialized systems",
                            "Integration challenge"
                        ],
                        practiceItems: [
                            "Design platform combining multiple systems"
                        ],
                        assessment: "Ready for intensive interview practice"
                    }
                ]
            },

            // Add weeks 9-12 to the completeProgram object:

            week9: {
                number: 9,
                title: "Interview Technique Mastery",
                subtitle: "Days 57-63",
                description: "Daily mock interviews with concept reinforcement and technique improvement",
                days: [
                    {
                        number: 57,
                        title: "Mock Interview - URL Shortener",
                        description: "Focus on fundamentals with structured interview practice",
                        theory: 30,
                        practice: 90,
                        topics: [
                            "Interview framework (RESHADED)",
                            "Requirements gathering",
                            "High-level design",
                            "Deep dive discussions"
                        ],
                        practiceItems: [
                            "60 min: Mock interview with URL shortener problem",
                            "30 min: Analysis and improvement notes",
                            "30 min: Reinforce weak concepts identified"
                        ],
                        interviewFocus: "Fundamentals and basic system design principles"
                    },
                    {
                        number: 58,
                        title: "Mock Interview - Social Media Feed",
                        description: "Focus on algorithms and feed generation strategies",
                        theory: 30,
                        practice: 90,
                        topics: [
                            "Fan-out strategies discussion",
                            "Algorithm complexity analysis",
                            "Trade-off explanations",
                            "Scale considerations"
                        ],
                        practiceItems: [
                            "60 min: Mock interview with social media feed",
                            "30 min: Algorithm deep-dive analysis",
                            "30 min: Study feed generation patterns"
                        ],
                        interviewFocus: "Algorithms and complex system interactions"
                    },
                    {
                        number: 59,
                        title: "Mock Interview - Chat System",
                        description: "Focus on real-time systems and message delivery",
                        theory: 30,
                        practice: 90,
                        topics: [
                            "Real-time communication patterns",
                            "Message delivery guarantees",
                            "WebSocket vs alternatives",
                            "Presence and notification systems"
                        ],
                        practiceItems: [
                            "60 min: Mock interview with chat system",
                            "30 min: Real-time systems analysis",
                            "30 min: Study WebSocket implementations"
                        ],
                        interviewFocus: "Real-time systems and communication protocols"
                    },
                    {
                        number: 60,
                        title: "Mock Interview - Video Streaming",
                        description: "Focus on infrastructure and content delivery",
                        theory: 30,
                        practice: 90,
                        topics: [
                            "CDN architecture deep-dive",
                            "Video encoding strategies",
                            "Global distribution challenges",
                            "Bandwidth optimization"
                        ],
                        practiceItems: [
                            "60 min: Mock interview with video streaming",
                            "30 min: Infrastructure analysis",
                            "30 min: Study CDN implementations"
                        ],
                        interviewFocus: "Infrastructure scaling and content delivery"
                    },
                    {
                        number: 61,
                        title: "Mock Interview - Ride Sharing",
                        description: "Focus on geospatial systems and matching algorithms",
                        theory: 30,
                        practice: 90,
                        topics: [
                            "Geospatial indexing strategies",
                            "Matching algorithm optimization",
                            "Real-time location tracking",
                            "Dynamic pricing models"
                        ],
                        practiceItems: [
                            "60 min: Mock interview with ride sharing",
                            "30 min: Geospatial systems analysis",
                            "30 min: Study location-based services"
                        ],
                        interviewFocus: "Geospatial systems and optimization algorithms"
                    },
                    {
                        number: 62,
                        title: "Mock Interview - E-commerce",
                        description: "Focus on transactions and consistency",
                        theory: 30,
                        practice: 90,
                        topics: [
                            "Transaction management",
                            "Inventory consistency",
                            "Payment processing",
                            "Order fulfillment workflows"
                        ],
                        practiceItems: [
                            "60 min: Mock interview with e-commerce platform",
                            "30 min: Transaction systems analysis",
                            "30 min: Study consistency patterns"
                        ],
                        interviewFocus: "Transactions and data consistency"
                    },
                    {
                        number: 63,
                        title: "Mock Interview - Search Engine",
                        description: "Focus on distributed systems and information retrieval",
                        theory: 30,
                        practice: 90,
                        topics: [
                            "Distributed indexing strategies",
                            "Query processing optimization",
                            "Relevance ranking algorithms",
                            "Crawling and freshness"
                        ],
                        practiceItems: [
                            "60 min: Mock interview with search engine",
                            "30 min: Distributed systems analysis",
                            "30 min: Study search algorithms"
                        ],
                        interviewFocus: "Distributed systems and search algorithms",
                        resources: [
                            "Pramp - Free peer interviews",
                            "InterviewBit - Structured practice",
                            "Exponent - AI-powered feedback"
                        ]
                    }
                ]
            },

            week10: {
                number: 10,
                title: "Advanced System Design Patterns",
                subtitle: "Days 64-70",
                description: "Master advanced patterns for complex, real-world system architectures",
                days: [
                    {
                        number: 64,
                        title: "Advanced Database Patterns",
                        description: "Federation, CQRS, multi-tenant architecture, database-per-service",
                        theory: 60,
                        practice: 60,
                        topics: [
                            "Database federation strategies",
                            "CQRS with event sourcing implementation",
                            "Multi-tenant architecture patterns",
                            "Database-per-service patterns"
                        ],
                        practiceItems: [
                            "Design federated database system",
                            "Implement CQRS pattern",
                            "Build multi-tenant SaaS architecture",
                            "Plan microservice data strategy"
                        ],
                        problems: [
                            "Design multi-tenant SaaS platform"
                        ]
                    },
                    {
                        number: 65,
                        title: "Advanced Caching Strategies",
                        description: "Multi-level caching, warming strategies, distributed consistency",
                        theory: 60,
                        practice: 60,
                        topics: [
                            "Multi-level caching hierarchies",
                            "Cache warming strategies",
                            "Distributed caching with consistency",
                            "Cache penetration and stampede prevention"
                        ],
                        practiceItems: [
                            "Design multi-tier caching system",
                            "Implement cache warming mechanisms",
                            "Build distributed cache with consistency",
                            "Create anti-stampede mechanisms"
                        ],
                        problems: [
                            "Design caching for global social network"
                        ]
                    },
                    {
                        number: 66,
                        title: "Advanced Security Patterns",
                        description: "Zero-trust architecture, OAuth 2.0, API security, threat modeling",
                        theory: 60,
                        practice: 60,
                        topics: [
                            "Zero-trust architecture design",
                            "OAuth 2.0 and OpenID Connect",
                            "API security and threat modeling",
                            "Data encryption at rest and in transit"
                        ],
                        practiceItems: [
                            "Design zero-trust system",
                            "Implement OAuth 2.0 flow",
                            "Create API security framework",
                            "Build encryption strategy"
                        ],
                        problems: [
                            "Design secure financial services platform"
                        ]
                    },
                    {
                        number: 67,
                        title: "Advanced Monitoring & Observability",
                        description: "Chaos engineering, advanced metrics, distributed tracing at scale",
                        theory: 60,
                        practice: 60,
                        topics: [
                            "Chaos engineering principles",
                            "Advanced metrics and alerting",
                            "Distributed tracing at scale",
                            "Performance optimization strategies"
                        ],
                        practiceItems: [
                            "Design chaos engineering experiments",
                            "Build advanced monitoring system",
                            "Implement distributed tracing",
                            "Create performance optimization framework"
                        ],
                        problems: [
                            "Design observability for microservices platform"
                        ]
                    },
                    {
                        number: 68,
                        title: "Advanced Data Processing",
                        description: "Real-time stream processing, data lakes, analytics pipelines, governance",
                        theory: 60,
                        practice: 60,
                        topics: [
                            "Real-time stream processing at scale",
                            "Data lake and warehouse integration",
                            "Advanced analytics pipelines",
                            "Data governance and privacy"
                        ],
                        practiceItems: [
                            "Build real-time processing system",
                            "Design data lake architecture",
                            "Create analytics pipeline",
                            "Implement data governance"
                        ],
                        problems: [
                            "Design data platform for autonomous vehicles"
                        ]
                    },
                    {
                        number: 69,
                        title: "Edge Computing & Global Systems",
                        description: "Edge architectures, global load balancing, cross-region sync, latency optimization",
                        theory: 60,
                        practice: 60,
                        topics: [
                            "Edge computing architectures",
                            "Global load balancing strategies",
                            "Cross-region data synchronization",
                            "Latency optimization techniques"
                        ],
                        practiceItems: [
                            "Design edge computing system",
                            "Build global load balancer",
                            "Implement cross-region sync",
                            "Optimize for global latency"
                        ],
                        problems: [
                            "Design global gaming platform"
                        ]
                    },
                    {
                        number: 70,
                        title: "Week 10 Review & Advanced Mock Interview",
                        description: "Complex multi-system design and identify remaining gaps",
                        theory: 60,
                        practice: 120,
                        topics: [
                            "Advanced system integration",
                            "Complex trade-off discussions"
                        ],
                        practiceItems: [
                            "120 min: Advanced mock interview with complex multi-system design",
                            "60 min: Review and analysis of remaining gaps"
                        ],
                        assessment: "Advanced mock interview with complex requirements"
                    }
                ]
            },

            week11: {
                number: 11,
                title: "Industry-Specific Deep Dives",
                subtitle: "Days 71-77",
                description: "Explore specialized systems across different industry verticals",
                days: [
                    {
                        number: 71,
                        title: "FinTech Systems Deep Dive",
                        description: "High-frequency trading, blockchain integration, regulatory compliance",
                        theory: 60,
                        practice: 60,
                        topics: [
                            "High-frequency trading systems",
                            "Blockchain integration patterns",
                            "Regulatory compliance automation",
                            "Cross-border payment systems"
                        ],
                        practiceItems: [
                            "Design HFT architecture",
                            "Integrate blockchain components",
                            "Build compliance system",
                            "Create payment processing"
                        ],
                        problems: [
                            "Design cryptocurrency exchange"
                        ]
                    },
                    {
                        number: 72,
                        title: "HealthTech Systems Deep Dive",
                        description: "HIPAA compliance, medical device integration, telemedicine, health analytics",
                        theory: 60,
                        practice: 60,
                        topics: [
                            "HIPAA-compliant architectures",
                            "Medical device integration",
                            "Telemedicine platforms",
                            "Health data analytics"
                        ],
                        practiceItems: [
                            "Design HIPAA-compliant system",
                            "Integrate medical devices",
                            "Build telemedicine platform",
                            "Create health analytics"
                        ],
                        problems: [
                            "Design electronic health records system"
                        ]
                    },
                    {
                        number: 73,
                        title: "EdTech Systems Deep Dive",
                        description: "Adaptive learning algorithms, virtual classrooms, assessment systems",
                        theory: 60,
                        practice: 60,
                        topics: [
                            "Adaptive learning algorithms",
                            "Virtual classroom technologies",
                            "Assessment and proctoring systems",
                            "Learning analytics platforms"
                        ],
                        practiceItems: [
                            "Build adaptive learning system",
                            "Create virtual classroom",
                            "Design assessment platform",
                            "Implement learning analytics"
                        ],
                        problems: [
                            "Design massive online learning platform"
                        ]
                    },
                    {
                        number: 74,
                        title: "AdTech Systems Deep Dive",
                        description: "Real-time bidding, ad fraud detection, attribution modeling",
                        theory: 60,
                        practice: 60,
                        topics: [
                            "Real-time bidding systems",
                            "Ad fraud detection",
                            "Attribution modeling",
                            "Privacy-compliant targeting"
                        ],
                        practiceItems: [
                            "Build RTB system",
                            "Create fraud detection",
                            "Implement attribution model",
                            "Design privacy-compliant ads"
                        ],
                        problems: [
                            "Design programmatic advertising platform"
                        ]
                    },
                    {
                        number: 75,
                        title: "Supply Chain Systems Deep Dive",
                        description: "Inventory optimization, demand forecasting, logistics optimization",
                        theory: 60,
                        practice: 60,
                        topics: [
                            "Inventory optimization algorithms",
                            "Demand forecasting systems",
                            "Logistics and routing optimization",
                            "Supplier relationship management"
                        ],
                        practiceItems: [
                            "Build inventory optimization",
                            "Create demand forecasting",
                            "Implement route optimization",
                            "Design supplier management"
                        ],
                        problems: [
                            "Design global supply chain platform"
                        ]
                    },
                    {
                        number: 76,
                        title: "Climate Tech Systems Deep Dive",
                        description: "Environmental monitoring, carbon tracking, renewable energy optimization",
                        theory: 60,
                        practice: 60,
                        topics: [
                            "Environmental monitoring systems",
                            "Carbon footprint tracking",
                            "Renewable energy optimization",
                            "Sustainability analytics"
                        ],
                        practiceItems: [
                            "Build environmental monitoring",
                            "Create carbon tracking",
                            "Optimize renewable energy",
                            "Implement sustainability analytics"
                        ],
                        problems: [
                            "Design smart city environmental platform"
                        ]
                    },
                    {
                        number: 77,
                        title: "Week 11 Review & Industry Focus",
                        description: "Choose specialization and build industry-focused portfolio project",
                        theory: 60,
                        practice: 120,
                        topics: [
                            "Choose your industry specialization",
                            "Deep dive into preferred sector"
                        ],
                        practiceItems: [
                            "Specialized mock interview in chosen industry",
                            "Begin industry-focused portfolio project"
                        ],
                        assessment: "Industry-specific system design problem"
                    }
                ]
            },

            week12: {
                number: 12,
                title: "Final Preparation & Portfolio",
                subtitle: "Days 78-84",
                description: "Intensive interview practice, portfolio development, and readiness assessment",
                days: [
                    {
                        number: 78,
                        title: "Intensive Mock Interview Practice - Day 1",
                        description: "Back-to-back interviews focusing on weakest areas",
                        theory: 0,
                        practice: 150,
                        topics: [
                            "2 back-to-back mock interviews",
                            "Different interviewers/platforms",
                            "Focus on weakest areas"
                        ],
                        practiceItems: [
                            "First 75-min mock interview",
                            "Short break and feedback review",
                            "Second 75-min mock interview",
                            "Detailed performance analysis"
                        ]
                    },
                    {
                        number: 79,
                        title: "Intensive Mock Interview Practice - Day 2",
                        description: "Advanced system integration and multi-part problems",
                        theory: 0,
                        practice: 150,
                        topics: [
                            "Advanced system integration problems",
                            "Multi-part system design",
                            "Trade-off discussions"
                        ],
                        practiceItems: [
                            "Complex multi-system integration interview",
                            "Deep-dive technical discussions",
                            "Advanced trade-off scenarios",
                            "Performance optimization challenges"
                        ]
                    },
                    {
                        number: 80,
                        title: "Intensive Mock Interview Practice - Day 3",
                        description: "Behavioral + technical combination under pressure",
                        theory: 0,
                        practice: 150,
                        topics: [
                            "Behavioral + technical combination",
                            "Communication and leadership scenarios",
                            "Problem-solving under pressure"
                        ],
                        practiceItems: [
                            "Combined behavioral-technical interview",
                            "Leadership and communication assessment",
                            "High-pressure problem solving",
                            "Stress testing and time management"
                        ]
                    },
                    {
                        number: 81,
                        title: "Portfolio Development - Day 1",
                        description: "Document best designs and create architecture diagrams",
                        theory: 0,
                        practice: 180,
                        topics: [
                            "Document 3-5 best system designs",
                            "Create architecture diagrams",
                            "Write detailed explanations"
                        ],
                        practiceItems: [
                            "Select and document top 5 system designs",
                            "Create professional architecture diagrams",
                            "Write comprehensive design explanations",
                            "Prepare presentation materials"
                        ]
                    },
                    {
                        number: 82,
                        title: "Portfolio Development - Day 2",
                        description: "Build working prototypes and deploy demonstrations",
                        theory: 0,
                        practice: 180,
                        topics: [
                            "Build working prototypes",
                            "Deploy to cloud platforms",
                            "Create demonstration videos"
                        ],
                        practiceItems: [
                            "Build distributed chat system prototype",
                            "Deploy AI-powered recommendation engine",
                            "Create real-time analytics dashboard",
                            "Build cloud-native microservices platform"
                        ],
                        portfolioComponents: [
                            "Distributed chat system",
                            "AI-powered recommendation engine",
                            "Real-time analytics dashboard",
                            "Cloud-native microservices platform"
                        ]
                    },
                    {
                        number: 83,
                        title: "Final Review & Strategy",
                        description: "Comprehensive review and interview strategy preparation",
                        theory: 120,
                        practice: 60,
                        topics: [
                            "Review all major concepts",
                            "Practice explaining trade-offs",
                            "Prepare for common follow-up questions"
                        ],
                        practiceItems: [
                            "Practice problem-solving framework (RESHADED)",
                            "Prepare clarifying questions for each problem type",
                            "Review common pitfalls and how to avoid them",
                            "Practice drawing clean architecture diagrams quickly"
                        ]
                    },
                    {
                        number: 84,
                        title: "Mock Final Interview & Readiness Assessment",
                        description: "Final simulation and comprehensive readiness evaluation",
                        theory: 60,
                        practice: 120,
                        topics: [
                            "Full system design interview simulation",
                            "Include follow-up questions and deep dives",
                            "Get feedback on communication and technical depth"
                        ],
                        practiceItems: [
                            "120 min: Full final mock interview simulation",
                            "60 min: Self-evaluate against interview criteria",
                            "Identify any last-minute areas for review",
                            "Plan post-90-day continued learning"
                        ],
                        assessment: "Final readiness evaluation and certification"
                    }
                ]
            }
        };

        const advancedProblems = {
            faangProblems: [
                {
                    company: "Meta",
                    problem: "Design Instagram Stories with global reach",
                    focus: "Real-time content delivery, global CDN optimization"
                },
                {
                    company: "Google",
                    problem: "Design YouTube live streaming with chat",
                    focus: "Live video processing, real-time messaging at scale"
                },
                {
                    company: "Amazon",
                    problem: "Design Prime delivery optimization system",
                    focus: "Logistics optimization, real-time tracking"
                },
                {
                    company: "Apple",
                    problem: "Design iCloud synchronization across devices",
                    focus: "Cross-device sync, conflict resolution"
                },
                {
                    company: "Netflix",
                    problem: "Design content recommendation with A/B testing",
                    focus: "ML pipeline, experimentation platform"
                }
            ],
            unicornProblems: [
                {
                    company: "Stripe",
                    problem: "Design global payment processing system",
                    focus: "Financial transactions, global compliance"
                },
                {
                    company: "Airbnb",
                    problem: "Design booking and reservation system",
                    focus: "Inventory management, booking conflicts"
                },
                {
                    company: "Spotify",
                    problem: "Design music streaming with social features",
                    focus: "Content delivery, social graph"
                },
                {
                    company: "Snapchat",
                    problem: "Design ephemeral messaging system",
                    focus: "Temporary content, privacy"
                },
                {
                    company: "TikTok",
                    problem: "Design short-video recommendation engine",
                    focus: "Video processing, ML recommendations"
                }
            ]
        };

        function renderMasteryWeeks() {
            const container = document.getElementById('masteryWeeks');
            const weeks = [completeProgram.week9, completeProgram.week10, completeProgram.week11, completeProgram.week12];

            container.innerHTML = weeks.map(week => `
        <div class="week-card bounce-in" style="animation-delay: ${(week.number - 9) * 0.1}s">
            <div class="week-header">
                <div class="week-number">${week.number}</div>
                <div class="week-title">
                    <h3>${week.title}</h3>
                    <div class="week-subtitle">${week.subtitle}</div>
                </div>
            </div>
            <p style="color: var(--gray); margin-bottom: 1.5rem;">${week.description}</p>
            <div class="progress-bar">
                <div class="progress-fill" style="width: ${calculateWeekProgress(week.number)}%"></div>
            </div>
            <ul class="days-list">
                ${week.days.map(day => `
                    <li class="day-item" onclick="openDayModal(${JSON.stringify(day).replace(/"/g, '&quot;')})">
                        <div class="day-checkbox ${completedDays.includes(day.number) ? 'completed' : ''}" 
                             onclick="event.stopPropagation(); toggleDayCompletion(${day.number})">
                            ${completedDays.includes(day.number) ? '✓' : ''}
                        </div>
                        <div class="day-content">
                            <div class="day-title">Day ${day.number}: ${day.title}</div>
                            <div class="day-desc">${day.description}</div>
                        </div>
                    </li>
                `).join('')}
            </ul>
        </div>
    `).join('');
        }

        function renderWeeklyProgress() {
            const container = document.getElementById('weeklyProgress');
            const weeks = [
                completeProgram.week1, completeProgram.week2, completeProgram.week3, completeProgram.week4,
                completeProgram.week5, completeProgram.week6, completeProgram.week7, completeProgram.week8,
                completeProgram.week9, completeProgram.week10, completeProgram.week11, completeProgram.week12
            ];

            container.innerHTML = weeks.map(week => {
                const progress = calculateWeekProgress(week.number);
                return `
            <div style="display: flex; align-items: center; margin-bottom: 1rem; padding: 1rem; background: ${progress === 100 ? '#f0f9ff' : '#f8fafc'}; border-radius: 8px; border-left: 4px solid ${progress === 100 ? 'var(--success)' : 'var(--primary)'};">
                <div style="flex: 1;">
                    <h4 style="margin: 0; color: var(--dark);">Week ${week.number}: ${week.title}</h4>
                    <p style="margin: 0.25rem 0 0 0; color: var(--gray); font-size: 0.875rem;">${week.subtitle}</p>
                </div>
                <div style="width: 120px; margin: 0 1rem;">
                    <div class="progress-bar" style="margin: 0;">
                        <div class="progress-fill" style="width: ${progress}%;"></div>
                    </div>
                </div>
                <div style="font-weight: 600; color: ${progress === 100 ? 'var(--success)' : 'var(--primary)'}; min-width: 50px; text-align: right;">
                    ${progress}%
                </div>
            </div>
        `;
            }).join('');
        }

        function renderFoundationWeeks() {
            const container = document.getElementById('foundationWeeks');
            const weeks = [completeProgram.week1, completeProgram.week2, completeProgram.week3, completeProgram.week4];

            container.innerHTML = weeks.map(week => `
                <div class="week-card bounce-in" style="animation-delay: ${(week.number - 1) * 0.1}s">
                    <div class="week-header">
                        <div class="week-number">${week.number}</div>
                        <div class="week-title">
                            <h3>${week.title}</h3>
                            <div class="week-subtitle">${week.subtitle}</div>
                        </div>
                    </div>
                    <p style="color: var(--gray); margin-bottom: 1.5rem;">${week.description}</p>
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: ${calculateWeekProgress(week.number)}%"></div>
                    </div>
                    <ul class="days-list">
                        ${week.days.map(day => `
                            <li class="day-item" onclick="openDayModal(${JSON.stringify(day).replace(/"/g, '&quot;')})">
                                <div class="day-checkbox ${completedDays.includes(day.number) ? 'completed' : ''}" 
                                     onclick="event.stopPropagation(); toggleDayCompletion(${day.number})">
                                    ${completedDays.includes(day.number) ? '✓' : ''}
                                </div>
                                <div class="day-content">
                                    <div class="day-title">Day ${day.number}: ${day.title}</div>
                                    <div class="day-desc">${day.description}</div>
                                </div>
                            </li>
                        `).join('')}
                    </ul>
                </div>
            `).join('');
        }

        function calculateWeekProgress(weekNumber) {
            const startDay = (weekNumber - 1) * 7 + 1;
            const endDay = weekNumber * 7;
            const weekDays = [];

            for (let i = startDay; i <= endDay; i++) {
                weekDays.push(i);
            }

            const completedInWeek = weekDays.filter(day => completedDays.includes(day)).length;
            return Math.round((completedInWeek / weekDays.length) * 100);
        }

        function renderPracticeWeeks() {
            const container = document.getElementById('practiceWeeks');
            const weeks = [completeProgram.week5, completeProgram.week6, completeProgram.week7, completeProgram.week8];

            container.innerHTML = weeks.map(week => `
        <div class="week-card bounce-in" style="animation-delay: ${(week.number - 5) * 0.1}s">
            <div class="week-header">
                <div class="week-number">${week.number}</div>
                <div class="week-title">
                    <h3>${week.title}</h3>
                    <div class="week-subtitle">${week.subtitle}</div>
                </div>
            </div>
            <p style="color: var(--gray); margin-bottom: 1.5rem;">${week.description}</p>
            <div class="progress-bar">
                <div class="progress-fill" style="width: ${calculateWeekProgress(week.number)}%"></div>
            </div>
            <ul class="days-list">
                ${week.days.map(day => `
                    <li class="day-item" onclick="openDayModal(${JSON.stringify(day).replace(/"/g, '&quot;')})">
                        <div class="day-checkbox ${completedDays.includes(day.number) ? 'completed' : ''}" 
                             onclick="event.stopPropagation(); toggleDayCompletion(${day.number})">
                            ${completedDays.includes(day.number) ? '✓' : ''}
                        </div>
                        <div class="day-content">
                            <div class="day-title">Day ${day.number}: ${day.title}</div>
                            <div class="day-desc">${day.description}</div>
                        </div>
                    </li>
                `).join('')}
            </ul>
        </div>
    `).join('');
        }

        // Update the modal content to handle new fields
        function openDayModal(dayData) {
            const modal = document.getElementById('dayModal');
            const modalTitle = document.getElementById('modalTitle');
            const modalSubtitle = document.getElementById('modalSubtitle');
            const modalBody = document.getElementById('modalBody');

            modalTitle.textContent = `Day ${dayData.number}: ${dayData.title}`;
            modalSubtitle.textContent = dayData.description;

            let bodyContent = '';

            if (dayData.topics) {
                bodyContent += `
            <div class="activity-section">
                <h4>📚 Theory (${dayData.theory || 60} min)</h4>
                <ul style="list-style: none; padding-left: 1rem;">
                    ${dayData.topics.map(topic => `<li style="margin-bottom: 0.5rem; padding-left: 1.5rem; position: relative;">
                        <span style="position: absolute; left: 0; color: var(--primary);">•</span>
                        ${topic}
                    </li>`).join('')}
                </ul>
            </div>
        `;
            }

            if (dayData.studyLinks) {
                bodyContent += `
            <div class="activity-section">
                <h4>🔗 Study Links</h4>
                <div class="study-links">
                    ${dayData.studyLinks.map(link => `
                        <a href="#" class="study-link">
                            <span style="margin-right: 0.75rem;">📖</span>
                            ${link}
                        </a>
                    `).join('')}
                </div>
            </div>
        `;
            }

            if (dayData.practiceItems) {
                bodyContent += `
            <div class="activity-section">
                <h4>💻 Practice (${dayData.practice || 45} min)</h4>
                <ul style="list-style: none; padding-left: 1rem;">
                    ${dayData.practiceItems.map(item => `<li style="margin-bottom: 0.75rem; padding: 1rem; background: #f8fafc; border-radius: 8px; border-left: 4px solid var(--success);">
                        ${item}
                    </li>`).join('')}
                </ul>
            </div>
        `;
            }

            if (dayData.problems) {
                bodyContent += `
            <div class="activity-section">
                <div class="problems-list">
                    <h5>🧩 Problems to Solve</h5>
                    <ul style="list-style: none; padding-left: 1rem; margin-top: 1rem;">
                        ${dayData.problems.map(problem => `<li style="margin-bottom: 0.5rem; padding-left: 1.5rem; position: relative;">
                            <span style="position: absolute; left: 0; color: #92400e;">▶</span>
                            ${problem}
                        </li>`).join('')}
                    </ul>
                </div>
            </div>
        `;
            }

            if (dayData.interviewFocus) {
                bodyContent += `
            <div class="activity-section">
                <h4>🎯 Interview Focus</h4>
                <div style="padding: 1.5rem; background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; border-radius: 12px; font-weight: 500;">
                    ${dayData.interviewFocus}
                </div>
            </div>
        `;
            }

            if (dayData.portfolioComponents) {
                bodyContent += `
            <div class="activity-section">
                <h4>🏗️ Portfolio Components</h4>
                <div style="display: grid; gap: 0.75rem; margin: 1rem 0;">
                    ${dayData.portfolioComponents.map(component => `
                        <div style="padding: 1rem; background: #fef3c7; border-radius: 8px; border-left: 4px solid #f59e0b;">
                            <strong>${component}</strong>
                        </div>
                    `).join('')}
                </div>
            </div>
        `;
            }

            if (dayData.resources) {
                bodyContent += `
            <div class="activity-section">
                <h4>🛠️ Resources</h4>
                <div style="display: grid; gap: 0.75rem; margin: 1rem 0;">
                    ${dayData.resources.map(resource => `
                        <div style="padding: 1rem; background: #ede9fe; border-radius: 8px; border-left: 4px solid var(--secondary);">
                            ${resource}
                        </div>
                    `).join('')}
                </div>
            </div>
        `;
            }

            if (dayData.miniProject) {
                bodyContent += `
            <div class="activity-section">
                <h4>🚀 Mini Project</h4>
                <div style="padding: 1.5rem; background: var(--gradient); color: white; border-radius: 12px; font-weight: 500;">
                    ${dayData.miniProject}
                </div>
            </div>
        `;
            }

            if (dayData.assessment) {
                bodyContent += `
            <div class="activity-section">
                <h4>✅ Assessment</h4>
                <div style="padding: 1.5rem; background: #fef2f2; border-radius: 12px; border-left: 4px solid var(--danger); color: var(--dark);">
                    ${dayData.assessment}
                </div>
            </div>
        `;
            }

            modalBody.innerHTML = bodyContent;
            modal.classList.add('active');
            document.body.style.overflow = 'hidden';
        }

        // Initialize the app
        document.addEventListener('DOMContentLoaded', function () {
            renderFoundationWeeks();
            renderPracticeWeeks();
            renderMasteryWeeks();
            renderWeeklyProgress();
            updateProgress();
        });

        // Click outside modal to close
        document.getElementById('dayModal').addEventListener('click', function (e) {
            if (e.target === this) {
                closeDayModal();
            }
        });
    </script>
</body>

</html>
